interface ActionObject {
  action: string;
  fullname: string;
  alias: string[];
  customAlias?: string;
  valueReg?: RegExp;
}

interface MatchedAction {
  aliasMatchDegree: "exactly" | "fussy" | "none";
  valueMatchDegree: "invalid" | "valid" | "notExist" | "notAccpet" | "none";
  action: ActionObject;
  matchedAlias: string | "none";
  isFuzzySearch?: boolean;
  extendedParam?: string;
}

interface inputActionObject {
  name: string;
  value: string;
}

const reg = {
  number: /^\d+(.\d+)?$/,
  hexColor: /^([\d|a-f|A-F]{1,3}|[\d|a-f|A-F]{6}|[\d|a-f|A-F]{8})$/,
};

const actionList: ActionObject[] = [
  {
    action: "resizeWidth",
    fullname: "width",
    alias: ["w"],
    valueReg: reg.number,
  },
  {
    action: "resizeHeight",
    fullname: "height",
    alias: ["h"],
    valueReg: reg.number,
  },
  {
    action: "rescaleWidth",
    fullname: "scale width",
    alias: ["sw"],
    valueReg: reg.number,
  },
  {
    action: "rescaleHeight",
    fullname: "scale height",
    alias: ["sh"],
    valueReg: reg.number,
  },
  {
    action: "rescale",
    fullname: "scale",
    alias: ["s"],
    valueReg: reg.number,
  },
  {
    action: "rescaleHalf",
    fullname: "scale half",
    alias: ["shf"],
  },
  // {
  //   action: "fontSize",
  //   fullname: "font size",
  //   alias: ["fs"],
  //   valueReg: reg.number,
  // },
  {
    action: "lineHeight",
    fullname: "line height",
    alias: ["lht"],
    valueReg: reg.number,
  },
  {
    action: "toggleFill",
    fullname: "toggle fill",
    alias: ["f"],
  },
  {
    action: "fillColorHex",
    fullname: "fill color hex #",
    alias: ["f#"],
    valueReg: reg.hexColor,
  },
  { action: "toggleStroke", fullname: "toggle stroke", alias: ["st", "b"] },
  {
    action: "strokeWidth",
    fullname: "stroke width",
    alias: ["stw", "bw"],
    valueReg: reg.number,
  },
  {
    action: "strokeTopWidth",
    fullname: "stroke top width",
    alias: ["stt", "bt"],
    valueReg: reg.number,
  },
  {
    action: "strokeRightWidth",
    fullname: "stroke right width",
    alias: ["str", "br"],
    valueReg: reg.number,
  },
  {
    action: "strokeBottomWidth",
    fullname: "stroke bottom width",
    alias: ["stb", "bb"],
    valueReg: reg.number,
  },
  {
    action: "strokeLeftWidth",
    fullname: "stroke left width",
    alias: ["stl", "bl"],
    valueReg: reg.number,
  },
  {
    action: "strokeColorHex",
    fullname: "stroke color hex #",
    alias: ["st#", "b#"],
    valueReg: reg.hexColor,
  },
  {
    action: "strokeAlignOutside",
    fullname: "stroke align outside",
    alias: ["sto", "bo"],
  },
  {
    action: "strokeAlignCenter",
    fullname: "stroke align center",
    alias: ["stc", "bc"],
  },
  {
    action: "strokeAlignInside",
    fullname: "stroke align inside",
    alias: ["sti", "bi"],
  },
  {
    action: "layoutHorizontal",
    fullname: "layout horizontal",
    alias: ["lh", "row"],
  },
  {
    action: "layoutVertical",
    fullname: "layout vertical",
    alias: ["lv", "col"],
  },
  {
    action: "layoutGap",
    fullname: "layout gap",
    alias: ["g"],
    valueReg: reg.number,
  },
  { action: "spaceBetween", fullname: "space between", alias: ["sb"] },
  {
    action: "justifyContentStart",
    fullname: "justifycontent start",
    alias: ["js"],
  },
  {
    action: "justifyContentCenter",
    fullname: "justifycontent center",
    alias: ["jc"],
  },
  {
    action: "justifyContentEnd",
    fullname: "justifycontent end",
    alias: ["je"],
  },
  {
    action: "alignItemsStart",
    fullname: "alignitems start",
    alias: ["as"],
  },
  {
    action: "alignItemsCenter",
    fullname: "alignitems center",
    alias: ["ac"],
  },
  {
    action: "alignItemsEnd",
    fullname: "alignitems end",
    alias: ["ae"],
  },
  {
    action: "placeItemsCenter",
    fullname: "place items center",
    alias: ["pc"],
  },
  {
    action: "padding",
    fullname: "padding",
    alias: ["p"],
    valueReg: reg.number,
  },
  {
    action: "paddingLeft",
    fullname: "padding left",
    alias: ["pl"],
    valueReg: reg.number,
  },
  {
    action: "paddingRight",
    fullname: "padding right",
    alias: ["pr"],
    valueReg: reg.number,
  },
  {
    action: "paddingTop",
    fullname: "padding top",
    alias: ["pt"],
    valueReg: reg.number,
  },
  {
    action: "paddingBottom",
    fullname: "padding bottom",
    alias: ["pb"],
    valueReg: reg.number,
  },
  {
    action: "paddingLeftRight",
    fullname: "padding left right",
    alias: ["px"],
    valueReg: reg.number,
  },
  {
    action: "paddingTopBottom",
    fullname: "padding top bottom",
    alias: ["py"],
    valueReg: reg.number,
  },
  {
    action: "moveRight",
    fullname: "move right",
    alias: ["mr"],
    valueReg: reg.number,
  },
  {
    action: "moveLeft",
    fullname: "move left",
    alias: ["ml"],
    valueReg: reg.number,
  },
  {
    action: "moveUp",
    fullname: "move up",
    alias: ["mu"],
    valueReg: reg.number,
  },
  {
    action: "moveDown",
    fullname: "move down",
    alias: ["md"],
    valueReg: reg.number,
  },
  {
    action: "widthHug",
    fullname: "width hug",
    alias: ["wh"],
  },
  {
    action: "widthFixed",
    fullname: "width fixed",
    alias: ["wfx"],
  },
  {
    action: "widthFill",
    fullname: "width fill",
    alias: ["wf"],
  },
  {
    action: "heightHug",
    fullname: "height hug",
    alias: ["hh"],
  },
  {
    action: "heightFixed",
    fullname: "height fixed",
    alias: ["hfx"],
  },
  {
    action: "heightFill",
    fullname: "height fill",
    alias: ["hf"],
  },
  {
    action: "contentBox",
    fullname: "content box",
    alias: ["contentbox"],
  },
  {
    action: "borderBox",
    fullname: "border box",
    alias: ["borderbox"],
  },
  {
    action: "radius",
    fullname: "radius",
    alias: ["r"],
    valueReg: reg.number,
  },
  {
    action: "radiusTop",
    fullname: "radius top",
    alias: ["rt"],
    valueReg: reg.number,
  },
  {
    action: "radiusRight",
    fullname: "radius right",
    alias: ["rr"],
    valueReg: reg.number,
  },
  {
    action: "radiusBottom",
    fullname: "radius bottom",
    alias: ["rb"],
    valueReg: reg.number,
  },
  {
    action: "radiusLeft",
    fullname: "radius left",
    alias: ["rl"],
    valueReg: reg.number,
  },
  {
    action: "radiusTopRight",
    fullname: "radius top right",
    alias: ["rtr", "rrt"],
    valueReg: reg.number,
  },
  {
    action: "radiusTopLeft",
    fullname: "radius top left",
    alias: ["rtl", "rlt"],
    valueReg: reg.number,
  },
  {
    action: "radiusBottomRight",
    fullname: "radius bottom right",
    alias: ["rbr", "rrb"],
    valueReg: reg.number,
  },
  {
    action: "radiusBottomLeft",
    fullname: "radius bottom left",
    alias: ["rbl", "rlb"],
    valueReg: reg.number,
  },
  {
    action: "radiusFull",
    fullname: "radius full",
    alias: ["rf"],
  },
  {
    action: "cornerSmoothing",
    fullname: "corner smoothing",
    alias: ["cs"],
    valueReg: reg.number,
  },
  {
    action: "cornerSmoothingIos",
    fullname: "corner smoothing as iOS",
    alias: ["csi"],
  },
  {
    action: "rotation",
    fullname: "rotation",
    alias: ["ro"],
    valueReg: reg.number,
  },
  {
    action: "rotationInverse",
    fullname: "inverse rotation",
    alias: ["ro-"],
    valueReg: reg.number,
  },
  {
    action: "distance",
    fullname: "distance horizontal",
    alias: ["dh", "d"],
    valueReg: reg.number,
  },
  {
    action: "distanceVertical",
    fullname: "distance vertical",
    alias: ["dv"],
    valueReg: reg.number,
  },
  {
    action: "fullHeight",
    fullname: "full height",
    alias: ["hfull", "fh"],
  },
  {
    action: "fullWidth",
    fullname: "full width",
    alias: ["wfull", "fw"],
  },
  {
    action: "absolute",
    fullname: "absolute position (ignore auto layout)",
    alias: ["abs"],
  },
  {
    action: "relative",
    fullname: "relative position (auto layout)",
    alias: ["rela"],
  },
  {
    action: "fitContent",
    fullname: "fit content",
    alias: ["fc"],
  },
  {
    action: "heightFitContent",
    fullname: "height fit content",
    alias: ["hfc"],
  },
  {
    action: "widthFitContent",
    fullname: "width fit content",
    alias: ["wfc"],
  },
];

// Configuration management functions
async function loadCustomAliases(): Promise<void> {
  try {
    const savedAliases = await figma.clientStorage.getAsync("custom-aliases");
    if (savedAliases) {
      const customAliases = JSON.parse(savedAliases);
      actionList.forEach(action => {
        if (customAliases[action.action]) {
          action.customAlias = customAliases[action.action];
        }
      });
    }
  } catch (error) {
    console.error("Error loading custom aliases:", error);
  }
}

async function saveCustomAliases(): Promise<void> {
  try {
    const customAliases: { [key: string]: string } = {};
    actionList.forEach(action => {
      if (action.customAlias) {
        customAliases[action.action] = action.customAlias;
      }
    });
    await figma.clientStorage.setAsync("custom-aliases", JSON.stringify(customAliases));
  } catch (error) {
    console.error("Error saving custom aliases:", error);
  }
}

function updateActionListFromUI(updatedActionList: ActionObject[]): void {
  updatedActionList.forEach((updatedAction, index) => {
    if (actionList[index] && actionList[index].action === updatedAction.action) {
      actionList[index].customAlias = updatedAction.customAlias;
    }
  });
}

function splitNameValue(param): inputActionObject | null {
  // This function only split action name and value, not validate the value
  let splitReg = /^([a-z|A-Z]+[#|-]{0,1})(.*)$/;
  let regResult = splitReg.exec(param);
  if (regResult) {
    return {
      name: regResult[1],
      value: regResult[2],
    };
  } else {
    return null;
  }
}

// Fuzzy search input parser for fullname matching
function parseFuzzySearchInput(input: string): { keyword: string; value: string } {
  // Remove extra spaces and trim
  input = input.trim().replace(/\s+/g, ' ');

  // Pattern to match value at the end: numbers or #xxx format
  const valuePattern = /(\s*(#[a-fA-F0-9]*|\d+(?:\.\d+)?))$/;
  const valueMatch = input.match(valuePattern);

  if (valueMatch) {
    const value = valueMatch[1].trim();
    const keyword = input.substring(0, input.length - valueMatch[0].length).trim();
    return { keyword, value };
  }

  return { keyword: input, value: '' };
}

// Enhanced fuzzy search function with character sequence matching
function fuzzySearchActions(keyword: string, value: string, actionList: ActionObject[]): MatchedAction[] {
  if (!keyword) return [];

  const keywordLower = keyword.toLowerCase();
  const matchedActions: { action: MatchedAction; score: number }[] = [];

  actionList.forEach(actionItem => {
    const fullnameLower = actionItem.fullname.toLowerCase();

    // Method 1: Direct substring match (highest priority)
    if (fullnameLower.includes(keywordLower)) {
      matchedActions.push({
        action: {
          aliasMatchDegree: "fussy",
          valueMatchDegree: "none",
          action: actionItem,
          matchedAlias: actionItem.alias[0]
        },
        score: 1000 + (100 - fullnameLower.length) // Higher score for exact matches and shorter names
      });
      return;
    }

    // Method 2: Character sequence matching (for typos and abbreviations)
    const sequenceScore = getCharacterSequenceScore(keywordLower, fullnameLower);
    if (sequenceScore > 0) {
      matchedActions.push({
        action: {
          aliasMatchDegree: "fussy",
          valueMatchDegree: "none",
          action: actionItem,
          matchedAlias: actionItem.alias[0]
        },
        score: sequenceScore
      });
    }
  });

  // Sort by score (descending), then by fullname length (ascending)
  matchedActions.sort((a, b) => {
    const scoreDiff = b.score - a.score;
    if (scoreDiff !== 0) return scoreDiff;
    return a.action.action.fullname.length - b.action.action.fullname.length;
  });

  return matchedActions.map(item => item.action);
}

// Character sequence matching function
function getCharacterSequenceScore(input: string, target: string): number {
  if (!input || !target) return 0;

  let inputIndex = 0;
  let targetIndex = 0;
  let matchedChars = 0;
  let consecutiveMatches = 0;
  let maxConsecutive = 0;

  // Remove spaces from target for better matching
  const cleanTarget = target.replace(/\s+/g, '');

  while (inputIndex < input.length && targetIndex < cleanTarget.length) {
    if (input[inputIndex] === cleanTarget[targetIndex]) {
      matchedChars++;
      consecutiveMatches++;
      maxConsecutive = Math.max(maxConsecutive, consecutiveMatches);
      inputIndex++;
    } else {
      consecutiveMatches = 0;
    }
    targetIndex++;
  }

  // Calculate score based on:
  // 1. Percentage of input characters matched
  // 2. Bonus for consecutive matches
  // 3. Penalty for length difference
  const matchRatio = matchedChars / input.length;
  const consecutiveBonus = maxConsecutive / input.length;
  const lengthPenalty = Math.abs(input.length - cleanTarget.length) / Math.max(input.length, cleanTarget.length);

  // Only return positive score if most characters matched
  if (matchRatio < 0.6) return 0;

  const score = (matchRatio * 100) + (consecutiveBonus * 20) - (lengthPenalty * 10);
  return Math.max(0, score);
}

function matchAction(param: string, actionItem: ActionObject): MatchedAction {
  const inputAction: inputActionObject = splitNameValue(param);

  let aliasMatchDegree: "exactly" | "fussy" | "none" = "none",
    valueMatchDegree: "invalid" | "valid" | "notExist" | "notAccpet" | "none" =
      "none",
    matchedAlias: string = "none";

  if (!inputAction) {
    return {
      aliasMatchDegree: "none",
      valueMatchDegree: "none",
      action: actionItem,
      matchedAlias: "none",
    };
  }

  // console.log(inputAction);
  const { alias, valueReg, customAlias } = actionItem;

  // Check custom alias first (highest priority)
  if (customAlias && customAlias === inputAction.name) {
    aliasMatchDegree = "exactly";
    matchedAlias = customAlias;
  } else if (customAlias && customAlias.includes(inputAction.name)) {
    aliasMatchDegree = "fussy";
    matchedAlias = customAlias;
  } else {
    // Check default aliases
    for (let aliasName of alias) {
      // Exactly match alias will override fussy match alias

      if (aliasName.includes(inputAction.name)) {
        aliasMatchDegree = "fussy";
        matchedAlias = aliasName;
      }

      if (aliasName === inputAction.name) {
        aliasMatchDegree = "exactly";
        matchedAlias = aliasName;
      }
      // console.log(matchedAlias);
    }
  }

  if (aliasMatchDegree !== "none") {
    if (valueReg == undefined) {
      // Action not accpet a value but a value is input
      if (inputAction.value) {
        valueMatchDegree = "notAccpet";
      }
    } else {
      // Action need a value

      if (inputAction.value === "") {
        // Value is empty
        valueMatchDegree = "notExist";
      } else {
        // Value is input
        let valueMatchResult = valueReg.exec(inputAction.value);
        if (valueMatchResult === null) {
          valueMatchDegree = "invalid";
        } else {
          valueMatchDegree = "valid";
        }
      }
    }
  }

  // console.log(matchedAlias, aliasMatchDegree);
  return {
    aliasMatchDegree: aliasMatchDegree,
    valueMatchDegree: valueMatchDegree,
    action: actionItem,
    matchedAlias: matchedAlias,
  };
}

function matchActionList(
  param: string,
  actionList: ActionObject[]
): MatchedAction[] {
  let exactlyMatched: MatchedAction;
  let fussyMatchedArray: MatchedAction[] = [];

  actionList.map((actionItem: ActionObject) => {
    let matchActionResult = matchAction(param, actionItem);
    // console.log(matchActionResult);
    switch (matchActionResult.aliasMatchDegree) {
      case "exactly":
        exactlyMatched = matchActionResult;
        break;
      case "fussy":
        fussyMatchedArray.push(matchActionResult);
        break;
      default:
        break;
    }
  });

  // console.log(fussyMatchedArray);
  // Sort array by alias name
  if (fussyMatchedArray.length > 1) {
    fussyMatchedArray.sort((a, b) => {
      const nameA = a.matchedAlias.toUpperCase(); // ignore upper and lowercase
      const nameB = b.matchedAlias.toUpperCase(); // ignore upper and lowercase
      if (nameA < nameB) {
        return -1;
      }
      if (nameA > nameB) {
        return 1;
      }
      // names must be equal
      return 0;
    });
  }

  // Concat exactly and fussy matched actions
  let matchedList = [];
  if (exactlyMatched) {
    matchedList.push(exactlyMatched);
  }
  matchedList = matchedList.concat(fussyMatchedArray);

  // console.log(matchedList);
  return matchedList;
}

function lastItemIsEmpty(inputArray: string[]): boolean {
  return inputArray[inputArray.length - 1] === "" ? true : false;
}

function valueValidMessage(degree: "invalid" | "notExist" | "notAccpet") {
  let message = "";
  // Ignore valid degree
  switch (degree) {
    case "invalid":
      message = "invalid value";
      break;
    case "notExist":
      message = "must input a value";
      break;
    case "notAccpet":
      message = "not accpet value";
      break;
    default:
      break;
  }
  return message;
}

// Utility function to safely access node properties
function safeNodeAccess(node: SceneNode, requiredProperties: string[], callback: (node: any) => void) {
  try {
    // Check if all required properties exist on the node
    const hasAllProperties = requiredProperties.every(prop => prop in node);
    if (hasAllProperties) {
      callback(node as any);
    }
  } catch (err) {
    console.log(err);
  }
}

async function main() {
  // Load custom aliases on startup
  await loadCustomAliases();

  // Start to control the histroy logic
  const history = await figma.clientStorage.getAsync("commands-histroy");
  // figma.clientStorage.setAsync("commands-histroy", undefined);

  async function updateHistroy(name) {
    let newHistory = [];
    if (history) {
      if (history.length > 6) {
        newHistory = history.slice(0, 6);
      } else {
        newHistory = history;
      }
    }
    newHistory.unshift(name);
    await figma.clientStorage.setAsync("commands-histroy", newHistory);
    console.log("histroy updated");
  }

  let suggestions: string[] = [];

  if (history) {
    suggestions = JSON.parse(JSON.stringify(history));
    suggestions.push("⚙️ View commands list & Customize aliases");
  } else {
    suggestions = [
      "w14 -- width 14",
      "shf -- scale half",
      "f -- toggle fill",
      "bb0.5 -- stroke bottom width 0.5",
      "⚙️ View commands list & Customize aliases",
    ];
  }
  // End to control the histroy logic

  // The 'input' event listens for text change in the Quick Actions box after a plugin is 'Tabbed' into.
  figma.parameters.on("input", ({ key, query, result }) => {
    switch (key) {
      case "actions":
        let errMessage = "";

        if (query === "") {
          result.setSuggestions(suggestions);
        } else {
          try {
            // Control variable for fuzzy search
            let onFuzzyMatch = false;
            let fuzzyMatchStartIndex = -1;

            // Start to match input param with action list
            let inputParamArray = query.split(" ");
            let paramArray = inputParamArray.filter((item) => item !== "");
            let validParam = [];
            let matchedActions = [];
            let suggestions = [];

            // First pass: try normal alias matching
            for (let i = 0; i < paramArray.length; i++) {
              let param = paramArray[i];
              let paramMatchedActions = matchActionList(param, actionList);

              if (paramMatchedActions.length === 0) {
                // No match found, enable fuzzy search mode
                onFuzzyMatch = true;
                fuzzyMatchStartIndex = i;
                break;
              } else {
                // Check if this is a valid match for previous params
                if (i < paramArray.length - 1 || lastItemIsEmpty(inputParamArray)) {
                  // Need to validate this param
                  let exactMatchedAction = paramMatchedActions.find(
                    (matchedAction) => matchedAction.aliasMatchDegree === "exactly"
                  );

                  if (exactMatchedAction &&
                    (exactMatchedAction.valueMatchDegree === "valid" ||
                      exactMatchedAction.valueMatchDegree === "none")) {
                    validParam.push(param);
                  } else {
                    errMessage = `⚠️ Error Command: ${param} is not a command`;
                    break;
                  }
                } else {
                  // Last param, don't validate value while typing
                  matchedActions = paramMatchedActions;
                }
              }
            }

            // If fuzzy match is enabled, handle remaining input
            if (onFuzzyMatch && errMessage === "") {
              // Get remaining input from fuzzy match start index
              let remainingInput = paramArray.slice(fuzzyMatchStartIndex).join(' ');

              // Parse fuzzy search input to separate keyword and value
              const { keyword, value } = parseFuzzySearchInput(remainingInput);

              // Perform fuzzy search on action fullnames
              const fuzzyMatches = fuzzySearchActions(keyword, value, actionList);

              if (fuzzyMatches.length > 0) {
                matchedActions = fuzzyMatches;
                // Mark as fuzzy search
                matchedActions.forEach(action => {
                  action.isFuzzySearch = true;
                  action.extendedParam = remainingInput;
                });
              } else {
                errMessage = `⚠️ Error Command: ${remainingInput} is not a command`;
              }
            }

            // Generate suggestions
            if (errMessage === "") {
              if (lastItemIsEmpty(inputParamArray) && !onFuzzyMatch) {
                // Show completed command
                suggestions = [validParam.join(", ")];
              } else {
                // Show matched actions as suggestions
                matchedActions.forEach((matchedAction) => {
                  let prefixText = validParam.length > 0 ? `${validParam.join(", ")}, ` : "";

                  if (matchedAction.isFuzzySearch) {
                    // For fuzzy search, use the parsed value
                    const inputParam = matchedAction.extendedParam || "";
                    const { keyword, value } = parseFuzzySearchInput(inputParam);
                    const cleanValue = value.startsWith('#') ? value.substring(1) : value;
                    let suggestionText = `${prefixText}${matchedAction.matchedAlias}${cleanValue} -- ${matchedAction.action.fullname} ${cleanValue}`;
                    suggestions.push(suggestionText);
                  } else {
                    // Normal alias matching
                    let currentParam = paramArray[paramArray.length - 1];
                    let actionValue = splitNameValue(currentParam)?.value || "";
                    let suggestionText = `${prefixText}${matchedAction.matchedAlias}${actionValue} -- ${matchedAction.action.fullname} ${actionValue}`;
                    suggestions.push(suggestionText);
                  }
                });
              }
              result.setSuggestions(suggestions);
            }
          } catch (err) {
            console.log("err", err);
            errMessage = "⚠️ The entered value is not supported";
          }

          if (errMessage !== "") {
            result.setError(errMessage);
          }
        }
        break;
      default:
        return;
    }
  });

  // When the user presses Enter after inputting all parameters, the 'run' event is fired.
  figma.on("run", ({ parameters }) => {
    startPluginWithParameters(parameters.actions);
  });
  // Start the plugin with parameters
  async function startPluginWithParameters(actions) {
    switch (actions) {
      case "⚙️ View commands list & Customize aliases":
        figma.showUI(__html__, {
          visible: true,
          width: 540,
          height: 500,
          title: "Quick Commands Settings"
        });

        figma.ui.onmessage = async (msg) => {
          switch (msg.type) {
            case "close-plugin":
              figma.closePlugin();
              break;
            case "get-action-list":
              figma.ui.postMessage({
                type: "action-list-data",
                data: actionList
              });
              break;
            case "save-action-list":
              updateActionListFromUI(msg.data);
              await saveCustomAliases();
              figma.ui.postMessage({
                type: "save-success"
              });
              figma.notify("Custom aliases saved successfully!");
              break;
            case "reset-aliases":
              // Reset all custom aliases
              actionList.forEach(action => {
                delete action.customAlias;
              });
              await saveCustomAliases();
              figma.ui.postMessage({
                type: "action-list-data",
                data: actionList
              });
              figma.notify("All custom aliases have been reset!");
              break;
            default:
              break;
          }
        };
        break;
      default:
        let inputQuery = actions.replace(/\s--.+$/, "");

        // Parse input with new fuzzy match logic
        let inputParamArray = inputQuery.split(" ");
        let paramArray = inputParamArray.filter((item) => item !== "").map(param => param.replace(/,+$/, "")); // Remove trailing commas
        let actions2Run: { action: ActionObject; value: string }[] = [];
        let inValidAction: boolean = false;
        let onFuzzyMatch = false;
        let fuzzyMatchStartIndex = -1;
        let validParam = [];

        // First pass: try normal alias matching
        for (let i = 0; i < paramArray.length; i++) {
          let param = paramArray[i];
          let paramMatchedActions = matchActionList(param, actionList);

          if (paramMatchedActions.length === 0) {
            // No match found, enable fuzzy search mode
            onFuzzyMatch = true;
            fuzzyMatchStartIndex = i;
            break;
          } else {
            // Find exact match for execution
            let exactMatchedAction = paramMatchedActions.find(
              (matchedAction) => matchedAction.aliasMatchDegree === "exactly"
            );

            if (exactMatchedAction) {
              // Validate value
              let { name, value } = splitNameValue(param);
              let valueValidState: "invalid" | "notExist" | "notAccpet" | undefined;

              if (exactMatchedAction.action.valueReg) {
                if (value === "") {
                  valueValidState = "notExist";
                } else {
                  let valueValidResult = exactMatchedAction.action.valueReg.exec(value);
                  if (valueValidResult === null) {
                    valueValidState = "invalid";
                  }
                }
              } else if (value !== "") {
                valueValidState = "notAccpet";
              }

              if (valueValidState) {
                inValidAction = true;
                let errMessage = `⚠️ Error Command: ${param} (${valueValidMessage(valueValidState)})`;
                console.log(errMessage);
                figma.notify(errMessage);
                figma.closePlugin();
                return;
              }

              actions2Run.push({ action: exactMatchedAction.action, value: value });
              validParam.push(param);
            } else {
              inValidAction = true;
              let errMessage = `⚠️ Error Command: ${param} is not a command`;
              console.log(errMessage);
              figma.notify(errMessage);
              figma.closePlugin();
              return;
            }
          }
        }

        // Handle fuzzy match if enabled
        if (onFuzzyMatch && !inValidAction) {
          let remainingInput = paramArray.slice(fuzzyMatchStartIndex).join(' ');
          const { keyword, value } = parseFuzzySearchInput(remainingInput);
          const fuzzyMatches = fuzzySearchActions(keyword, value, actionList);

          if (fuzzyMatches.length > 0) {
            const bestMatch = fuzzyMatches[0];
            const cleanValue = value.startsWith('#') ? value.substring(1) : value;

            // For fuzzy match, only validate value when executing, not during input
            let valueValidState: "invalid" | "notExist" | "notAccpet" | undefined;

            if (bestMatch.action.valueReg) {
              if (cleanValue === "") {
                valueValidState = "notExist";
              } else {
                let valueValidResult = bestMatch.action.valueReg.exec(cleanValue);
                if (valueValidResult === null) {
                  valueValidState = "invalid";
                }
              }
            } else if (cleanValue !== "") {
              valueValidState = "notAccpet";
            }

            if (valueValidState) {
              inValidAction = true;
              let errMessage = `⚠️ Error Command: ${remainingInput} (${valueValidMessage(valueValidState)})`;
              console.log(errMessage);
              figma.notify(errMessage);
              figma.closePlugin();
              return;
            }

            actions2Run.push({ action: bestMatch.action, value: cleanValue });
          } else {
            inValidAction = true;
            let errMessage = `⚠️ Error Command: ${remainingInput} is not a command`;
            console.log(errMessage);
            figma.notify(errMessage);
            figma.closePlugin();
            return;
          }
        }

        // Execute actions if all are valid
        if (!inValidAction) {
          actions2Run.forEach((item) => {
            console.log("run action", item.action);
            runAction(item.action, item.value);
          });
        }

        await updateHistroy(actions);
        figma.closePlugin();
    }
  }

  function runAction(actionObject: ActionObject, value: string) {
    let action = actionObject.action;
    switch (action) {
      case "resizeWidth":
        resizeWidth(value);
        break;
      case "resizeHeight":
        resizeHeight(value);
        break;
      case "rescaleWidth":
        rescaleWidth(value);
        break;
      case "rescaleHeight":
        rescaleHeight(value);
        break;
      case "rescale":
        rescale(value);
        break;
      case "rescaleHalf":
        rescale(0.5);
        break;
      case "fontSize":
        fontSize(value);
        break;
      case "lineHeight":
        lineHeight(value);
        break;
      case "toggleFill":
        toggleFill();
        break;
      case "fillColorHex":
        fillColor("HEX", value);
        break;
      case "toggleStroke":
        toggleStroke();
        break;
      case "strokeColorHex":
        strokeColor("HEX", value);
        break;
      case "strokeWidth":
        strokeWidth("all", value);
        break;
      case "strokeTopWidth":
        strokeWidth("top", value);
        break;
      case "strokeRightWidth":
        strokeWidth("right", value);
        break;
      case "strokeBottomWidth":
        strokeWidth("bottom", value);
        break;
      case "strokeLeftWidth":
        strokeWidth("left", value);
        break;
      case "strokeAlignOutside":
        strokeAlignOutside();
        break;
      case "strokeAlignCenter":
        strokeAlignCenter();
        break;
      case "strokeAlignInside":
        strokeAlignInside();
        break;
      case "layoutHorizontal":
        layoutHorizontal();
        break;
      case "layoutVertical":
        layoutVertical();
        break;
      case "spaceBetween":
        spaceBetween();
        break;
      case "justifyContentStart":
        justifyContentStart();
        break;
      case "justifyContentCenter":
        justifyContentCenter();
        break;
      case "justifyContentEnd":
        justifyContentEnd();
        break;
      case "alignItemsStart":
        alignItemsStart();
        break;
      case "alignItemsCenter":
        alignItemsCenter();
        break;
      case "alignItemsEnd":
        alignItemsEnd();
        break;
      case "placeItemsCenter":
        justifyContentCenter();
        alignItemsCenter();
        break;
      case "layoutGap":
        layoutGap(value);
        break;
      case "padding":
        padding("top", value);
        padding("bottom", value);
        padding("left", value);
        padding("right", value);
        break;
      case "paddingLeft":
        padding("left", value);
        break;
      case "paddingRight":
        padding("right", value);
        break;
      case "paddingTop":
        padding("top", value);
        break;
      case "paddingBottom":
        padding("bottom", value);
        break;
      case "paddingLeftRight":
        padding("left", value);
        padding("right", value);
        break;
      case "paddingTopBottom":
        padding("top", value);
        padding("bottom", value);
        break;
      case "contentBox":
        boxSizing("content");
        break;
      case "borderBox":
        boxSizing("border");
        break;
      case "moveRight":
        moveRight(value);
        break;
      case "moveLeft":
        moveLeft(value);
        break;
      case "moveUp":
        moveUp(value);
        break;
      case "moveDown":
        moveDown(value);
        break;
      case "widthHug":
        layoutResizing("h", "HUG");
        break;
      case "widthFixed":
        layoutResizing("h", "FIXED");
        break;
      case "widthFill":
        layoutResizing("h", "FILL");
        break;
      case "heightHug":
        layoutResizing("v", "HUG");
        break;
      case "heightFixed":
        layoutResizing("v", "FIXED");
        break;
      case "heightFill":
        layoutResizing("v", "FILL");
        break;
      case "radius":
        radius("all", value);
        break;
      case "radiusTop":
        radius("topRight", value);
        radius("topLeft", value);
        break;
      case "radiusRight":
        radius("topRight", value);
        radius("bottomRight", value);
        break;
      case "radiusBottom":
        radius("bottomRight", value);
        radius("bottomLeft", value);
        break;
      case "radiusLeft":
        radius("topLeft", value);
        radius("bottomLeft", value);
        break;
      case "radiusTopRight":
        radius("topRight", value);
        break;
      case "radiusTopLeft":
        radius("topLeft", value);
        break;
      case "radiusBottomRight":
        radius("bottomRight", value);
        break;
      case "radiusBottomLeft":
        radius("bottomLeft", value);
        break;
      case "radiusFull":
        radius("all", "999999");
        break;
      case "cornerSmoothing":
        cornerSmoothing(value);
        break;
      case "cornerSmoothingIos":
        cornerSmoothing(60);
        break;
      case "rotation":
        rotation(value);
        break;
      case "rotationInverse":
        rotation(-value);
        break;
      case "distance":
        distance(value);
        break;
      case "distanceVertical":
        distanceVertical(value);
        break;
      case "fullHeight":
        fullHeight();
        break;
      case "fullWidth":
        fullWidth();
        break;
      case "absolute":
        absolute();
        break;
      case "relative":
        relative();
        break;
      case "fitContent":
        fitContent("all");
        break;
      case "heightFitContent":
        fitContent("height");
        break;
      case "widthFitContent":
        fitContent("width");
        break;
    }
  }

  function fitContent(direction: "all" | "height" | "width") {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['children'], (node) => {
        if (node.children.length === 0) return;

        // Calculate bounding box of all children
        const bounds = node.children.reduce((acc, child) => {
          const childLeft = child.x;
          const childTop = child.y;
          const childRight = child.x + child.width;
          const childBottom = child.y + child.height;

          return {
            left: Math.min(acc.left, childLeft),
            top: Math.min(acc.top, childTop),
            right: Math.max(acc.right, childRight),
            bottom: Math.max(acc.bottom, childBottom),
          };
        }, {
          left: node.children[0].x,
          top: node.children[0].y,
          right: node.children[0].x + node.children[0].width,
          bottom: node.children[0].y + node.children[0].height,
        });

        const totalWidth = bounds.right - bounds.left;
        const totalHeight = bounds.bottom - bounds.top;

        switch (direction) {
          case "all":
            node.resize(totalWidth, totalHeight);
            break;
          case "height":
            node.resize(node.width, totalHeight);
            break;
          case "width":
            node.resize(totalWidth, node.height);
            break;
        }
      });
    });
  }

  function resizeWidth(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['resize'], (node) => {
        node.resize(Number(value), node.height);
      });
    });
  }
  function resizeHeight(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['resize'], (node) => {
        node.resize(node.width, Number(value));
      });
    });
  }
  function spaceBetween() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.primaryAxisAlignItems = "SPACE_BETWEEN";
      });
    });
  }
  function justifyContentStart() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.primaryAxisAlignItems = "MIN";
      });
    });
  }
  function justifyContentCenter() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.primaryAxisAlignItems = "CENTER";
      });
    });
  }
  function justifyContentEnd() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.primaryAxisAlignItems = "MAX";
      });
    });
  }
  function alignItemsStart() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.counterAxisAlignItems = "MIN";
      });
    });
  }
  function alignItemsCenter() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.counterAxisAlignItems = "CENTER";
      });
    });
  }
  function alignItemsEnd() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.counterAxisAlignItems = "MAX";
      });
    });
  }
  function layoutGap(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          node.layoutMode = "HORIZONTAL";
        }
        node.itemSpacing = Number(value);
      });
    });
  }
  function padding(direction, value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        if (node.layoutMode === "NONE") {
          figma.notify(
            `Cannot modify ${node.name}'s padding, it's not an auto-layout frame`
          );
        } else {
          value = Number(value);
          switch (direction) {
            case "left":
              node.paddingLeft = value;
              break;
            case "right":
              node.paddingRight = value;
              break;
            case "top":
              node.paddingTop = value;
              break;
            case "bottom":
              node.paddingBottom = value;
              break;
          }
        }
      });
    });
  }
  function rescale(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['rescale'], (node) => {
        let nodeWidth = node.width,
          nodeHeight = node.height;
        node.rescale(Number(value));
        node.x = node.x + (nodeWidth / 2 - node.width / 2);
        node.y = node.y + (nodeHeight / 2 - node.height / 2);
      });
    });
  }
  function rescaleWidth(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['rescale'], (node) => {
        let nodeWidth = node.width,
          nodeHeight = node.height;
        let scale = Number(value) / node.width;
        node.rescale(scale);
        node.x = node.x + (nodeWidth / 2 - node.width / 2);
        node.y = node.y + (nodeHeight / 2 - node.height / 2);
      });
    });
  }
  function rescaleHeight(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['rescale'], (node) => {
        let nodeWidth = node.width,
          nodeHeight = node.height;
        let scale = Number(value) / node.height;
        node.rescale(scale);
        node.x = node.x + (nodeWidth / 2 - node.width / 2);
        node.y = node.y + (nodeHeight / 2 - node.height / 2);
      });
    });
  }
  function fontSize(value) {
    // figma.currentPage.selection.map((node) => {
    //   try {
    //     async function loopTextNode(layer) {
    //       if (layer.type === "TEXT") {
    //         if (layer.fontName === figma.mixed) {
    //           await Promise.all(
    //             layer
    //               .getRangeAllFontNames(0, layer.characters.length)
    //               .map(figma.loadFontAsync)
    //           );
    //         } else {
    //           await figma.loadFontAsync(layer.fontName);
    //         }
    //         layer.fontSize = Number(value);
    //       }
    //       if ("children" in layer) {
    //         if (layer.children.length > 0) {
    //           layer.children.map((item) => {
    //             loopTextNode(item);
    //           });
    //         }
    //       }
    //     }
    //     await loopTextNode(node);
    //   } catch (err) {
    //     console.log(err);
    //   }
    // });

    console.log("Coming soon");
  }
  function lineHeight(value) {
    // Copy from fontSize()
    console.log("Coming soon");
  }
  function toggleFill() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['fills'], (node) => {
        let nodeFills = JSON.parse(JSON.stringify(node.fills));
        if (nodeFills.length === 0) {
          node.fills = [
            {
              type: "SOLID",
              visible: true,
              opacity: 1,
              blendMode: "NORMAL",
              color: {
                r: 0.7686274647712708,
                g: 0.7686274647712708,
                b: 0.7686274647712708,
              },
            },
          ];
        } else {
          // logic from Sketch app
          if (nodeFills[0].visible === true) {
            nodeFills.map((fill) => (fill.visible = false));
          } else {
            nodeFills.map((fill) => (fill.visible = true));
          }
          node.fills = nodeFills;
        }
      });
    });
  }
  function fillColor(valueType: "HEX" | "RGB" | "RGBA", value) {
    let r = 1,
      g = 1,
      b = 1,
      a = 1;
    function convertHex(hex: string) {
      console.log("hex", hex);
      return parseInt(hex, 16) / 255;
    }

    switch (valueType) {
      case "HEX":
        console.log(value.length);
        switch (value.length) {
          case 1:
            r = convertHex(value.repeat(2));
            g = r;
            b = r;
            break;
          case 2:
            r = convertHex(value);
            g = r;
            b = r;
            break;
          case 3:
            r = convertHex(value[0].repeat(2));
            g = convertHex(value[1].repeat(2));
            b = convertHex(value[2].repeat(2));
            break;
          case 6:
            r = convertHex(value.slice(0, 2));
            g = convertHex(value.slice(2, 4));
            b = convertHex(value.slice(4, 6));
            break;
          case 8:
            r = convertHex(value.slice(0, 2));
            g = convertHex(value.slice(2, 4));
            b = convertHex(value.slice(4, 6));
            a = convertHex(value.slice(6, 8));
            break;
          default:
            break;
        }
        break;
      default:
        break;
    }

    // console.log(r, g, b, a);

    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['fills'], (node) => {
        let nodeFills = JSON.parse(JSON.stringify(node.fills));
        if (nodeFills.length === 0) {
          node.fills = [
            {
              type: "SOLID",
              visible: true,
              opacity: a,
              blendMode: "NORMAL",
              color: {
                r: r,
                g: g,
                b: b,
              },
            },
          ];
        } else {
          nodeFills[nodeFills.length - 1].color = {
            r: r,
            g: g,
            b: b,
          };
          nodeFills[nodeFills.length - 1].opacity = a;
          node.fills = nodeFills;
        }
      });
    });
  }
  function toggleStroke() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokes'], (node) => {
        let nodeStrokes = JSON.parse(JSON.stringify(node.strokes));
        if (nodeStrokes.length === 0) {
          node.strokes = [
            {
              type: "SOLID",
              visible: true,
              opacity: 1,
              blendMode: "NORMAL",
              color: {
                r: 0,
                g: 0,
                b: 0,
              },
            },
          ];
        } else {
          // logic from Sketch app
          if (nodeStrokes[0].visible === true) {
            nodeStrokes.map((stroke) => (stroke.visible = false));
          } else {
            nodeStrokes.map((stroke) => (stroke.visible = true));
          }
          node.strokes = nodeStrokes;
        }
      });
    });
  }
  function strokeColor(valueType: "HEX" | "RGB" | "RGBA", value) {
    let r = 1,
      g = 1,
      b = 1,
      a = 1;
    function convertHex(hex: string) {
      console.log("hex", hex);
      return parseInt(hex, 16) / 255;
    }

    switch (valueType) {
      case "HEX":
        console.log(value.length);
        switch (value.length) {
          case 1:
            r = convertHex(value.repeat(2));
            g = r;
            b = r;
            break;
          case 2:
            r = convertHex(value);
            g = r;
            b = r;
            break;
          case 3:
            r = convertHex(value[0].repeat(2));
            g = convertHex(value[1].repeat(2));
            b = convertHex(value[2].repeat(2));
            break;
          case 6:
            r = convertHex(value.slice(0, 2));
            g = convertHex(value.slice(2, 4));
            b = convertHex(value.slice(4, 6));
            break;
          case 8:
            r = convertHex(value.slice(0, 2));
            g = convertHex(value.slice(2, 4));
            b = convertHex(value.slice(4, 6));
            a = convertHex(value.slice(6, 8));
            break;
          default:
            break;
        }
        break;
      default:
        break;
    }

    // console.log(r, g, b, a);

    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokes'], (node) => {
        let nodeStrokes = JSON.parse(JSON.stringify(node.strokes));
        if (nodeStrokes.length === 0) {
          node.strokes = [
            {
              type: "SOLID",
              visible: true,
              opacity: a,
              blendMode: "NORMAL",
              color: {
                r: r,
                g: g,
                b: b,
              },
            },
          ];
        } else {
          nodeStrokes[nodeStrokes.length - 1].color = {
            r: r,
            g: g,
            b: b,
          };
          nodeStrokes[nodeStrokes.length - 1].opacity = a;
          node.strokes = nodeStrokes;
        }
      });
    });
  }
  function strokeWidth(
    side: "all" | "top" | "right" | "bottom" | "left",
    value
  ) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokeWeight'], (node) => {
        if (typeof node.strokeWeight == "number") {
          // The code below solves a bug
          node.strokeWeight = node.strokeWeight;
        }
        switch (side) {
          case "all":
            node.strokeWeight = Number(value);
            break;
          case "top":
            node.strokeTopWeight = Number(value);
            break;
          case "right":
            node.strokeRightWeight = Number(value);
            break;
          case "bottom":
            node.strokeBottomWeight = Number(value);
            break;
          case "left":
            node.strokeLeftWeight = Number(value);
            break;
          default:
            break;
        }
        if (node.strokes.length === 0) {
          node.strokes = [
            {
              type: "SOLID",
              visible: true,
              opacity: 1,
              blendMode: "NORMAL",
              color: {
                r: 0,
                g: 0,
                b: 0,
              },
            },
          ];
        }
      });
    });
  }
  function strokeAlignOutside() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokeAlign'], (node) => {
        node.strokeAlign = "OUTSIDE";
      });
    });
  }
  function strokeAlignCenter() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokeAlign'], (node) => {
        node.strokeAlign = "CENTER";
      });
    });
  }
  function strokeAlignInside() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokeAlign'], (node) => {
        node.strokeAlign = "INSIDE";
      });
    });
  }
  function layoutHorizontal() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        let justifyContent = node.primaryAxisAlignItems;
        let itemsAlign = node.counterAxisAlignItems;

        node.layoutMode = "HORIZONTAL";

        node.primaryAxisAlignItems = itemsAlign;
        node.counterAxisAlignItems = justifyContent;
      });
    });
  }
  function layoutVertical() {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutMode'], (node) => {
        let justifyContent = node.primaryAxisAlignItems;
        let itemsAlign = node.counterAxisAlignItems;

        node.layoutMode = "VERTICAL";

        node.primaryAxisAlignItems = itemsAlign;
        node.counterAxisAlignItems = justifyContent;
      });
    });
  }
  function moveRight(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, [], (node) => {
        node.x += Number(value);
      });
    });
  }
  function boxSizing(value: "content" | "border") {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['strokesIncludedInLayout'], (node) => {
        switch (value) {
          case "content":
            node.strokesIncludedInLayout = true;
            break;
          case "border":
            node.strokesIncludedInLayout = false;
            break;
          default:
            break;
        }
      });
    });
  }
  function moveLeft(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, [], (node) => {
        node.x -= Number(value);
      });
    });
  }
  function moveUp(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, [], (node) => {
        node.y -= Number(value);
      });
    });
  }
  function moveDown(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, [], (node) => {
        node.y += Number(value);
      });
    });
  }
  function layoutResizing(
    direction: "h" | "v",
    style: "FIXED" | "HUG" | "FILL"
  ) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['layoutGrow', 'layoutAlign'], (node) => {
        switch (direction) {
          case "h":
            switch (style) {
              case "FILL":
                node.layoutSizingHorizontal = "FILL"
                break;
              case "FIXED":
                node.layoutSizingHorizontal = "FIXED"
                break;
              case "HUG":
                node.layoutSizingHorizontal = "HUG"
                break;
            }
            break;
          case "v":
            switch (style) {
              case "FILL":
                node.layoutSizingVertical = "FILL"
                break;
              case "FIXED":
                node.layoutSizingVertical = "FIXED"
                break;
              case "HUG":
                node.layoutSizingVertical = "HUG"
                break;
            }
            break;
        }
      });
    });
  }
  function radius(
    side: "all" | "topRight" | "topLeft" | "bottomRight" | "bottomLeft",
    value
  ) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['cornerRadius'], (node) => {
        switch (side) {
          case "all":
            node.cornerRadius = Number(value);
            break;
          case "topRight":
            node.topRightRadius = Number(value);
            break;
          case "topLeft":
            node.topLeftRadius = Number(value);
            break;
          case "bottomRight":
            node.bottomRightRadius = Number(value);
            break;
          case "bottomLeft":
            node.bottomLeftRadius = Number(value);
            break;
          default:
            break;
        }
      });
    });
  }
  function cornerSmoothing(value) {
    value > 100 ? (value = 100) : "";
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['cornerSmoothing'], (node) => {
        node.cornerSmoothing = Number(value) / 100;
      });
    });
  }
  function rotation(value) {
    figma.currentPage.selection.map((node) => {
      safeNodeAccess(node, ['absoluteBoundingBox', 'rotation'], (node) => {
        // <--- Matrix Plan Start --->
        // let matrix = node.relativeTransform;
        // console.log(matrix);
        // let tx = matrix[0][2];
        // let ty = matrix[1][2];

        // let width = node.width;
        // let height = node.height;

        // let centerX = tx + width / 2;
        // let centerY = ty + height / 2;

        // let angle = (Number(value) / 180) * Math.PI;
        // let rotationMatrix = [
        //   [Math.cos(angle), Math.sin(angle), tx],
        //   [-Math.sin(angle), Math.cos(angle), ty],
        // ];
        // let rotationCenterX =
        //   centerX * rotationMatrix[0][0] + centerY * rotationMatrix[0][1];
        // let rotationCenterY =
        //   centerX * rotationMatrix[1][0] + centerY * rotationMatrix[1][1];

        // console.log(rotationCenterX, rotationCenterY);

        // rotationMatrix[0][2] -= rotationCenterX - centerX;
        // rotationMatrix[1][2] -= rotationCenterY - centerY;

        // console.log(rotationMatrix);
        // node.relativeTransform = rotationMatrix;
        // <--- Matrix Plan End --->

        let nodeBox = node.absoluteBoundingBox;
        let nodeCenterPoint = {
          x: nodeBox.x + nodeBox.width / 2,
          y: nodeBox.y + nodeBox.height / 2,
        };

        node.rotation = Number(value);

        let newNodeBox = node.absoluteBoundingBox;
        let newNodeCenterPoint = {
          x: newNodeBox.x + newNodeBox.width / 2,
          y: newNodeBox.y + newNodeBox.height / 2,
        };

        node.x += nodeCenterPoint.x - newNodeCenterPoint.x;
        node.y += nodeCenterPoint.y - newNodeCenterPoint.y;
      });
    });
  }
  function distance(value) {
    const selection = figma.currentPage.selection;
    if (selection.length < 2) {
      figma.notify("Please select at least 2 objects to set distance");
      return;
    }

    // Simple approach: arrange horizontally based on current x positions
    const nodes = selection.slice().sort((a, b) => a.x - b.x);

    // Set new positions with specified distance
    let currentX = nodes[0].x;
    nodes.forEach((node, index) => {
      if (index > 0) {
        currentX += Number(value);
        node.x = currentX;
      }
      currentX += node.width;
    });
  }

  function distanceVertical(value) {
    const selection = figma.currentPage.selection;
    if (selection.length < 2) {
      figma.notify("Please select at least 2 objects to set distance");
      return;
    }

    // Arrange vertically based on current y positions
    const nodes = selection.slice().sort((a, b) => a.y - b.y);

    // Set new positions with specified distance
    let currentY = nodes[0].y;
    nodes.forEach((node, index) => {
      if (index > 0) {
        currentY += Number(value);
        node.y = currentY;
      }
      currentY += node.height;
    });
  }

  function fullHeight() {
    figma.currentPage.selection.forEach((node) => {
      if (node.parent && 'layoutMode' in node.parent && node.parent.layoutMode !== "NONE") {
        // Node is in auto layout frame
        safeNodeAccess(node, ['layoutGrow', 'layoutAlign', 'layoutPositioning'], (node) => {
          if ('layoutPositioning' in node && node.layoutPositioning === "ABSOLUTE") {
            // Absolute positioned in auto layout - manually set height and position
            if (node.parent && 'height' in node.parent) {
              node.resize(node.width, node.parent.height);
              node.y = 0;
            }
          } else {
            // Normal auto layout behavior
            node.layoutSizingVertical = "FILL"
          }
        });
      } else {
        // Node is not in auto layout, set height to match parent
        if (node.parent && 'height' in node.parent) {
          safeNodeAccess(node, ['resize'], (node) => {
            node.resize(node.width, node.parent.height);
          });
        }
      }
    });
  }

  function fullWidth() {
    figma.currentPage.selection.forEach((node) => {
      if (node.parent && 'layoutMode' in node.parent && node.parent.layoutMode !== "NONE") {
        // Node is in auto layout frame
        safeNodeAccess(node, ['layoutGrow', 'layoutAlign', 'layoutPositioning'], (node) => {
          if ('layoutPositioning' in node && node.layoutPositioning === "ABSOLUTE") {
            // Absolute positioned in auto layout - manually set width and position
            if (node.parent && 'width' in node.parent) {
              node.resize(node.parent.width, node.height);
              node.x = 0;
            }
          } else {
            // Normal auto layout behavior
            node.layoutSizingHorizontal = "FILL"
          }
        });
      } else {
        // Node is not in auto layout, set width to match parent
        if (node.parent && 'width' in node.parent) {
          safeNodeAccess(node, ['resize'], (node) => {
            node.resize(node.parent.width, node.height);
          });
        }
      }
    });
  }

  function absolute() {
    figma.currentPage.selection.forEach((node) => {
      if (node.parent && 'layoutMode' in node.parent && node.parent.layoutMode !== "NONE") {
        // Node is in auto layout frame, toggle positioning
        safeNodeAccess(node, ['layoutPositioning'], (node) => {
          if ('layoutPositioning' in node) {
            node.layoutPositioning = "ABSOLUTE";
          }
        });
      } else {
        // Node is not in auto layout, notify user
        figma.notify(`${node.name} is not in an auto layout frame`);
      }
    });
  }

  function relative() {
    figma.currentPage.selection.forEach((node) => {
      if (node.parent && 'layoutMode' in node.parent && node.parent.layoutMode !== "NONE") {
        // Node is in auto layout frame, toggle positioning
        safeNodeAccess(node, ['layoutPositioning'], (node) => {
          if ('layoutPositioning' in node) {
            node.layoutPositioning = "AUTO";
          }
        });
      } else {
        // Node is not in auto layout, notify user
        figma.notify(`${node.name} is not in an auto layout frame`);
      }
    });
  }
}

main();
