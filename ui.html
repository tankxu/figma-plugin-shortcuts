<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Shortcuts</title>
  <style>
    @font-face {
      font-family: 'Roboto Mono';
      src: url('https://static.figma.com/font/RobotoMono_wght__1') format('truetype');
      font-weight: 400;
      font-style: normal;
    }

    :root {
      --figma-color-bg: #ffffff;
      --figma-color-bg-secondary: #f5f5f5;
      --figma-color-bg-elevated: #ffffff;
      --figma-color-bg-hover: #f5f5f5;
      --figma-color-bg-pressed: #f5f5f5;
      --figma-color-bg-brand: #0d99ff;
      --figma-color-text: #000000E5;
      --figma-color-text-secondary: #00000080;
      --figma-color-text-tertiary: #b3b3b3;
      --figma-color-text-onbrand: #ffffff;
      --figma-color-text-tooltip: #ffffff;
      --figma-color-border: #e6e6e6;
      --figma-color-border-strong: #2c2c2c;
      --figma-color-border-translucent: #0000001a;
      --figma-color-border-success: #aff4c6;
      --figma-color-border-warning: #ffe8a3;
      --figma-color-border-warning-strong: #ffcd29;
      --figma-color-border-brand: #bde3ff;
      --figma-color-icon: #000000E5;
      --figma-color-icon-secondary: #b3b3b3;
      --figma-color-icon-tertiary: #d9d9d9;
      --figma-color-icon-onbrand: #ffffff;
      --figma-color-success: #14ae5c;
      --figma-color-warning: #f24822;
      --figma-color-bg-brand-hover: #007be5;
      --figma-color-bg-brand-pressed: #007be5;
      --figma-color-bg-brand-secondary: #0768cf;
      --figma-color-bg-brand-tertiary: #e5f4ff;
      --figma-color-bg-selected-secondary: #f2f9ff;
      --figma-color-bg-success-secondary: #008043;
      --figma-color-bg-success-tertiary: #d5f7da;
      --figma-color-bg-warning-secondary: #eba611;
      --figma-color-bg-warning-tertiary: #fff1c2;
      --figma-color-bg-tertiary: #e6e6e6;
      --figma-color-bg-tooltip: #1e1e1e;
      --figma-color-bg-menu: #1e1e1e;
      --figma-font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --figma-font-family-mono: 'Roboto Mono', 'Monaco', 'Courier New', monospace;
      --figma-elevation-300-tooltip: 0px 0px .5px rgba(0, 0, 0, .15), 0px 5px 12px rgba(0, 0, 0, .13), 0px 1px 3px rgba(0, 0, 0, .1);
      --figma-elevation-400-menu-panel: 0px 0px .5px rgba(0, 0, 0, .12), 0px 10px 16px rgba(0, 0, 0, .12), 0px 2px 5px rgba(0, 0, 0, .15);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: var(--figma-font-family);
      font-size: 11px;
      color: var(--figma-color-text);
      background: var(--figma-color-bg);
      margin: 0;
      padding: 0;
      user-select: none;
    }

    h2 {
      font-size: 15px;
      font-weight: 550;
      line-height: 25px;
      margin: 0;
    }

    p {
      margin: 0;
      font-size: 11px;
    }

    button {
      font-family: var(--figma-font-family);
    }

    .container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ========== Status Bar ========== */
    .status-bar-container {
      padding: 0;
    }

    .status-bar-container.hidden {
      display: none;
    }

    .status-bar {
      padding: 12px;
      height: 120px;
      background: var(--figma-color-bg-elevated);
      border: 0.5px solid var(--figma-color-border);
      box-shadow: 0 0.5px 0 0.5px var(--figma-color-border);
      text-align: center;
      font-size: 14px;
      line-height: 120%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
      transition: all 0.15s ease;
    }

    /* Status Bar States */
    .status-bar.wait-action {
      background: var(--figma-color-bg-success-tertiary);
      color: var(--figma-color-bg-success-secondary);
      border: 0.5px solid var(--figma-color-border-success);
    }

    .status-bar.listening-set,
    .status-bar.notify {
      background: var(--figma-color-bg-brand-tertiary);
      color: var(--figma-color-bg-brand-secondary);
      border: 0.5px solid var(--figma-color-border-brand);
    }

    .status-bar.warning {
      background: var(--figma-color-bg-warning-tertiary);
      color: var(--figma-color-bg-warning-secondary);
      border: 0.5px solid var(--figma-color-border-warning);
    }

    /* Floating Status Bar for Config Page */
    .status-bar.float {
      position: absolute;
      top: 8px;
      left: 8px;
      right: 8px;
      padding: 0 16px;
      border-radius: 5px;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.03), 0 2px 6px 0 rgba(0, 0, 0, 0.05);
      z-index: 1000;
      height: 84px;
    }

    .status-bar-title {
      font-size: 18px;
      font-weight: 550;
      line-height: 120%;
      margin: 0;
    }

    .status-bar.warning .status-bar-title,
    .status-bar.notify .status-bar-title {
      font-size: 13px;
      font-weight: 450 !important;
      line-height: 140%;
    }

    .status-bar-description {
      font-size: 11px;
      margin: 0;
    }

    .dots-animation {
      display: inline-block;
      width: 18px;
      text-align: left;
    }

    .dots-animation::after {
      content: "...";
      animation: dotsContent 1s infinite;
    }

    @keyframes dotsContent {
      0% {
        content: ".";
      }

      33% {
        content: "..";
      }

      66% {
        content: "...";
      }

      100% {
        content: ".";
      }
    }

    .content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px 16px;
      min-height: 0;
    }

    .card {
      background: var(--figma-color-bg-elevated);
      border: 1px solid var(--figma-color-border);
      border-radius: 5px;
      padding: 12px;
      margin-bottom: 8px;
    }

    .card:last-child {
      margin-bottom: 0;
    }

    .page {
      display: none;
    }

    .page.active {
      display: flex;
      flex-direction: column;
      height: 100%;
      gap: 0;
    }

    #mainPage {
      flex: 1;
      min-height: 0;
    }

    #mainPage .content {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .section-title {
      font-size: 11px;
      font-weight: 550;
      line-height: 16px;
      margin: 0;
    }

    .category-title {
      font-size: 11px;
      font-weight: 550;
      line-height: 16px;
      margin: 0;
      color: var(--figma-color-text);
      position: sticky;
      top: 0;
      background-color: var(--figma-color-bg);
      padding: 8px 0 4px;
      z-index: 10;
    }

    .category-title:first-child {
      margin-top: 0;
    }

    .shortcuts-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .shortcuts-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .iconBtnSmall {
      background: none;
      border: none;
      padding: 0;
      border-radius: 5px;
      transition: background-color 0.2s ease;
    }

    .iconBtnSmall:hover {
      background: var(--figma-color-bg-hover);
    }

    .iconBtnSmall svg,
    .iconBtnSmall svg * {
      pointer-events: none;
    }

    /* ==========  Shortcut Card  ========== */
    .shortcut-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 6px 6px 10px;
      background: var(--figma-color-bg);
      border: 1px solid var(--figma-color-border-translucent);
      border-radius: 5px;
      font-size: 11px;
      line-height: 130%;
      transition: background-color 0.15s ease;
      gap: 4px;
      position: relative;
      transition: all 0.15s ease;
    }

    .shortcut-card .shortcut-name {
      padding: 2px 0;
      color: var(--figma-color-text);
      font-weight: 500;
      word-break: break-word;
    }

    /* Custom action indicator */
    .shortcut-card.custom-action:before {
      content: '';
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2px;
      height: 16px;
      background-color: var(--figma-color-bg-brand);
      border-radius: 2px;
      position: absolute;
      left: 0px;
      transform: translate(-50%, 0);
    }

    .shortcut-card.clickable:hover {
      background-color: var(--figma-color-bg-hover);
    }

    .shortcut-card.clickable:hover .key-text,
    .shortcut-card.clickable:hover .action-button {
      background-color: var(--figma-color-text-onbrand);
    }

    /* Conflict indicator */
    .shortcut-card.conflict {
      border: 1px solid var(--figma-color-border-warning-strong);
    }

    /* ==========  Set Shortcut Button  ========== */
    .shortcut-button {
      display: flex;
      align-items: center;
      gap: 2px;
      background: none;
      border: none;
      padding: 0;
      font-size: 11px;
      min-height: 24px;
      position: relative;
      pointer-events: auto;
    }

    .shortcut-button.disabled {
      pointer-events: none;
    }

    /* Set Shortcut Action Button */
    .shortcut-button .action-button {
      background: var(--figma-color-bg-secondary);
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 11px;
      font-weight: 450;
      color: var(--figma-color-text-secondary);
      min-width: 80px;
      text-align: center;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
    }

    .shortcut-button .action-button.listening {
      background: var(--figma-color-bg-brand) !important;
      color: var(--figma-color-text-onbrand) !important;
    }

    /* Key Display */
    .shortcut-button .key-display {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .shortcut-button .key-text {
      background: var(--figma-color-bg-secondary);
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 11px;
      font-weight: 450;
      color: var(--figma-color-text);
      min-width: 16px;
      text-align: center;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 24px;
      min-width: 24px;
    }

    .shortcut-button .key-text.listening {
      background: var(--figma-color-bg-brand);
      color: var(--figma-color-text-onbrand);
    }

    /* Button States */
    .shortcut-button.state-empty .action-button {
      display: flex;
    }

    .shortcut-button.state-empty .key-display {
      display: none;
    }

    .shortcut-button.state-set .action-button {
      display: none;
    }

    .shortcut-button.state-set .key-display {
      display: flex;
    }

    .shortcut-button.state-listening .action-button {
      display: flex;
    }

    .shortcut-button.state-listening .key-display {
      display: none;
    }

    .footer {
      padding: 8px 12px;
      border-top: 1px solid var(--figma-color-border);
    }

    .button {
      padding: 0 12px;
      background: var(--figma-color-bg-brand);
      color: var(--figma-color-text-onbrand);
      border: none;
      border-radius: 5px;
      font-size: 11px;
      font-weight: 550;
      transition: all 0.1s ease;
      height: 32px;
      font-family: var(--figma-font-family);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .button:active {
      background: var(--figma-color-bg-brand-pressed);
    }

    .button.secondary {
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
      border: 1px solid var(--figma-color-border);
    }

    .button.plain {
      background: var(--figma-color-bg-secondary);
      color: var(--figma-color-text-secondary);
      border: none;
      font-weight: 450;
      height: 24px;
      padding: 4px 8px;
    }

    .button.warning {
      background: var(--figma-color-warning);
      color: var(--figma-color-text-onbrand);
    }

    .button.warning:hover {
      background: var(--figma-color-bg-warning-secondary);
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-bottom: 1px solid var(--figma-color-border);
      position: relative;
    }

    .header h2 {
      margin: 0;
      color: var(--figma-color-text);
      text-align: center;
      flex: 1;
    }

    .back-button {
      position: absolute;
      border: none;
      padding: 4px;
      color: var(--figma-color-icon);
      width: 28px;
      height: 28px;
      border-radius: 5px;
      transition: opacity 0.2s ease;
      transition: all 0.2s ease;
      background-color: var(--figma-color-bg);
    }

    .back-button:hover {
      opacity: 1;
      background-color: var(--figma-color-bg-hover);
    }

    .tabs-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      height: 40px;
      border-bottom: 1px solid var(--figma-color-border);
    }

    .tabs {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .tab {
      padding: 0 8px;
      height: 24px;
      background: var(--figma-color-bg);
      border: none;
      border-radius: 5px;
      font-size: 11px;
      font-weight: 450;
      color: var(--figma-color-text-secondary);
      transition: all 0.1s ease;
    }

    .tab.active {
      color: var(--figma-color-text);
      background: var(--figma-color-bg-secondary);
      font-weight: 550;
    }

    .tab:hover {
      background: var(--figma-color-bg-hover);
    }

    .config-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 4px 16px 16px;
    }

    .tab-content {
      display: none;
      padding: 0;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .tab-content.active {
      display: block;
    }

    #configPage .content {
      flex: 1;
      padding: 0px;
      background-color: var(--figma-color-bg);
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    #addCustomPage .content {
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .config-item {
      margin-bottom: 4px;
    }

    .config-item:last-child {
      margin-bottom: 0;
    }

    .add-custom-action-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 16px auto 8px;
    }

    .add-button {
      width: auto;
      padding: 8px 12px;
      background-color: var(--figma-color-bg);
      border: 1px solid var(--figma-color-border-translucent);
      border-radius: 5px;
      font-size: 11px;
      color: var(--figma-color-text);
      transition: all 0.1s ease;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-label {
      display: block;
      margin-bottom: 6px;
      font-size: 11px;
      color: var(--figma-color-text);
      font-weight: 500;
    }

    .form-input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--figma-color-border);
      border-radius: 5px;
      font-size: 11px;
      font-family: var(--figma-font-family);
      background: var(--figma-color-bg);
      color: var(--figma-color-text);
    }

    .form-input:focus {
      outline: none;
      border-color: var(--figma-color-bg-brand);
    }

    .form-textarea {
      min-height: 140px;
      resize: vertical;
    }

    .form-textarea.code-editor {
      list-style: 18px;
      font-family: var(--figma-font-family-mono);
      font-size: 11px;
    }

    .form-actions {
      display: flex;
      gap: 8px;
    }

    .form-actions .button {
      flex: 1;
      padding: 0;
    }

    .form-actions .button.more-actions {
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      max-width: 24px;
      border-radius: 0px 5px 5px 0px;
      border: none;
      transition: all 0.1s ease;
    }

    .form-actions .button.more-actions.active {
      background: var(--figma-color-bg-selected-secondary);
      color: var(--figma-color-bg-brand);
    }

    #customShortcutBtn {
      width: fit-content;
    }

    .more-action-button-group {
      display: flex;
      gap: 1px;
      flex: 1;
      position: relative;
    }

    .more-action-button-group .button#saveCustomBtnGroup {
      border-radius: 5px 0px 0px 5px;
    }

    .empty-state {
      text-align: center;
      padding: 24px;
      color: var(--figma-color-text-secondary);
      font-size: 11px;
    }

    .tabs-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.2s ease;
      width: 100%;
    }

    .search-content {
      display: none;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      transition: all 0.2s ease;
    }

    .search-content.active {
      display: flex;
    }

    .search-input-container {
      position: relative;
      flex: 1;
      margin-right: 8px;
    }

    .search-input {
      width: 100%;
      height: 24px;
      padding: 8px 8px 8px 24px;
      background: var(--figma-color-bg-secondary);
      border: none;
      border-radius: 5px;
      font-size: 11px;
      font-family: var(--figma-font-family);
      color: var(--figma-color-text);
      transition: all 0.2s ease;
    }

    .search-input:focus {
      outline: 1px solid var(--figma-color-bg-brand);
      background: var(--figma-color-bg);
    }

    .search-input::placeholder {
      color: var(--figma-color-text-secondary);
    }

    .search-icon {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }

    .search-icon svg {
      width: 24px;
      height: 24px;
    }

    .close-search-btn {
      background: none;
      border: none;
      padding: 0;
      border-radius: 5px;
      transition: background-color 0.2s ease;
    }

    .close-search-btn:hover {
      background: var(--figma-color-bg-hover);
    }

    .close-search-btn svg {
      width: 24px;
      height: 24px;
    }

    .footer-info-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 6px;
      z-index: 1000;
      pointer-events: none;
    }

    .footer-info-container.hidden {
      display: none;
    }

    .footer-info {
      padding: 8px;
      font-size: 11px;
      color: var(--figma-color-bg-brand);
      font-weight: 450;
      background: color-mix(in srgb, var(--figma-color-bg-brand-tertiary), transparent 20%);
      border: 0.5px solid var(--figma-color-border-brand);
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      border-radius: 99999px;
      text-align: center;
    }

    #focusable {
      position: absolute;
      top: -1000px;
      left: -1000px;
      opacity: 0;
      width: 1px;
      height: 1px;
    }

    .dropdown-menu {
      position: absolute;
      bottom: 40px;
      right: 0;
      background: #1e1e1e;
      border-radius: 13px;
      padding: 8px;
      box-shadow: var(--figma-elevation-400-menu-panel);
      min-width: 140px;
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .dropdown-menu .dropdown-item {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 5px;
      min-height: 24px;
      display: flex;
      align-items: center;
      justify-content: start;
      word-break: break-word;
      color: var(--figma-color-text-onbrand);
      text-align: left;
    }

    .dropdown-menu .dropdown-item:hover {
      background: var(--figma-color-bg-brand);
    }

    /* Tooltip styles */
    .tooltip {
      position: absolute;
      background: var(--figma-color-bg-tooltip);
      color: var(--figma-color-text-tooltip);
      border: 1px solid var(--figma-color-border);
      border-radius: 11px;
      padding: 12px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      width: calc(100% - 24px);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 4px;
      height: fit-content;
      line-height: 150%;
      text-align: center;
      font-weight: 450;
    }

    .tooltip.show {
      opacity: 1;
    }

    #corner {
      position: absolute;
      right: 1px;
      bottom: 2px;
      cursor: nwse-resize;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="status-bar-container" id="statusBarContainer">
      <div class="status-bar wait-action" id="statusBar">
        <p class="status-bar-title">Capturing Keys<span class="dots-animation"></span></p>
        <p class="status-bar-description">Press shortcuts / Click to run • ⌘+Click to configure</p>
      </div>
    </div>
    <div class="footer-info-container hidden">
      <div class="footer-info" id="footerInfo">
        <p>Click to run action • ⌘+Click to set shortcut</p>
      </div>
    </div>
    <!-- Main page -->
    <div class="page active" id="mainPage">
      <div class="content">
        <div class="shortcuts-list" id="shortcutsList">
          <div class="empty-state">
            <h2>No shortcuts configured yet</h2>
            <button class="button" id="configureBtn" style="margin-top: 16px;">Configure Shortcuts</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Configuration page -->
    <div class="page" id="configPage">
      <div class="header">
        <button class="back-button" id="backBtn"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18"
            viewBox="0 0 24 24">
            <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
              d="M20 12H4m0 0l6-6m-6 6l6 6" />
          </svg></button>
        <h2>Configure Shortcuts</h2>
        <div></div>
      </div>

      <div class="tabs-container">
        <div class="tabs-content">
          <div class="tabs">
            <button class="tab active" data-tab="default">Base Actions</button>
            <button class="tab" data-tab="custom">Custom Actions</button>
          </div>
          <button class="iconBtnSmall" id="searchBtn">
            <svg width="24" height="24" fill="none" viewBox="0 0 24 24">
              <path fill="var(--figma-color-icon)" fill-rule="evenodd"
                d="M16 11.5a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0m-.956 4.206a5.5 5.5 0 1 1 .662-.662.5.5 0 0 1 .148.102l3 3a.5.5 0 1 1-.707.707l-3-3a.5.5 0 0 1-.103-.147"
                clip-rule="evenodd">
              </path>
            </svg>
          </button>
        </div>
        <div class="search-content">
          <div class="search-input-container">
            <div class="search-icon">
              <svg width="16" height="16" fill="none" viewBox="0 0 24 24">
                <path fill="var(--figma-color-icon)" fill-rule="evenodd"
                  d="M16 11.5a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0m-.956 4.206a5.5 5.5 0 1 1 .662-.662.5.5 0 0 1 .148.102l3 3a.5.5 0 1 1-.707.707l-3-3a.5.5 0 0 1-.103-.147"
                  clip-rule="evenodd">
                </path>
              </svg>
            </div>
            <input type="text" class="search-input" id="searchInput" placeholder="Find..." />
          </div>
          <button class="close-search-btn" id="closeSearchBtn">
            <svg width="16" height="16" fill="none" viewBox="0 0 24 24">
              <path fill="var(--figma-color-icon)" fill-rule="evenodd"
                d="M17.354 6.646a.5.5 0 0 1 0 .708L12.707 12l4.647 4.646a.5.5 0 0 1-.708.708L12 12.707l-4.646 4.647a.5.5 0 0 1-.708-.708L11.293 12 6.646 7.354a.5.5 0 0 1 .708-.707L12 11.293l4.646-4.647a.5.5 0 0 1 .708 0"
                clip-rule="evenodd"></path>
            </svg>
          </button>
        </div>
      </div>

      <div class="content">
        <!-- Default actions tab -->
        <div class="tab-content active" id="defaultTab">
          <div class="config-list" id="defaultConfigList">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>

        <!-- Custom actions tab -->
        <div class="tab-content" id="customTab">
          <div class="add-custom-action-container">
            <button class="add-button" id="addCustomBtn">Add Custom Action</button>
          </div>
          <div class="config-list" id="customConfigList">
            <!-- Will be populated by JavaScript -->
          </div>
        </div>
      </div>
    </div>

    <!-- Add custom action page -->
    <div class="page" id="addCustomPage">
      <div class="header">
        <button class="back-button" id="backToConfigBtn"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18"
            viewBox="0 0 24 24">
            <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
              d="M20 12H4m0 0l6-6m-6 6l6 6" />
          </svg></button>
        <h2>Add Custom Action</h2>
        <div></div>
      </div>

      <div class="content">
        <div class="form-group">
          <label class="form-label">Name</label>
          <input type="text" class="form-input" id="customActionName" placeholder="Enter action name">
        </div>

        <div class="form-group">
          <label class="form-label">Function</label>
          <textarea class="form-input form-textarea code-editor" id="customActionFunction"
            placeholder="// Example:&#10;&#10;selection.forEach(node => {&#10;  if ('cornerRadius' in node) {&#10;    node.cornerRadius = 8;&#10;  }&#10;});"></textarea>
          <button class="button plain" id="testRunBtn" style="margin-top: 8px;">Test Run</button>
        </div>

        <div class="form-group">
          <label class="form-label">Shortcut</label>
          <div id="customShortcutBtn"></div>
        </div>

        <div class="form-actions">
          <button class="button secondary" id="cancelCustomBtn">Cancel</button>
          <button class="button" id="saveCustomBtn">Save</button>
          <div class="more-action-button-group" style="display: none;">
            <button class="button" id="saveCustomBtnGroup">Save</button>
            <button class="button more-actions" id="moreActionsBtn" type="button"><svg width="16" height="16"
                fill="none" viewBox="0 0 16 16">
                <path fill="currentColor" fill-rule="evenodd"
                  d="M10.475 6.768a.5.5 0 0 1 0 .707L8.354 9.596 8 9.95l-.354-.354-2.12-2.121a.5.5 0 0 1 .706-.707L8 8.536l1.768-1.768a.5.5 0 0 1 .707 0"
                  clip-rule="evenodd"></path>
              </svg></button>
            <div id="moreActionsDropdown" class="dropdown-menu" style="display:none;">
              <div class="dropdown-item" id="duplicateCustomBtn">Duplicate</div>
              <div class="dropdown-item" id="deleteCustomBtn">Delete</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <svg id="corner" width="14" height="14" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
      <g clip-path="url(#a)">
        <path stroke="#fff" stroke-opacity=".7" d="m17.354 1.354-16 16" />
        <path stroke="var(--figma-color-text)" stroke-opacity=".5" stroke-width=".5" d="m17.177 1.177-16 16" />
        <path stroke="#fff" stroke-opacity=".5" d="m19.354 4.354-16 16" />
        <path stroke="var(--figma-color-text)" stroke-opacity=".4" stroke-width=".5" d="m19.177 4.177-16 16" />
      </g>
      <defs>
        <clipPath id="a">
          <path fill="#fff" d="M0 0h14v14H0z" />
        </clipPath>
      </defs>
    </svg>

    <!-- Hidden input for capturing keyboard events -->
    <input type="text" id="focusable" tabindex="0">
  </div>

  <script>
    // ========== Refactored Global State ==========
    let currentPage = 'main';
    let currentTab = 'default';
    let shortcuts = {};
    let customActions = [];
    let defaultActions = {};
    let isListening = false;
    let listeningActionId = null;
    let platform = 'mac';
    let pressedCodes = new Set(); // Accumulated keys for display
    let currentlyPressed = new Set(); // Currently physically pressed keys
    let currentEditingActionId = null;
    let ignoreFirstKeyUp = false;
    let delayTimer = null;
    let shortcutSaved = false; // Whether the shortcut has been saved
    let tempShortcuts = {}; // Temporary shortcut storage
    // footerInfo related
    let isCmdDown = false;
    let isAltDown = false;

    // DOM elements
    const statusBarContainer = document.getElementById('statusBarContainer');
    const statusBar = document.getElementById('statusBar');
    const focusable = document.getElementById('focusable');
    const shortcutsList = document.getElementById('shortcutsList');
    const backBtn = document.getElementById('backBtn');
    const backToConfigBtn = document.getElementById('backToConfigBtn');
    const addCustomBtn = document.getElementById('addCustomBtn');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const pages = document.querySelectorAll('.page');
    const footerInfoContainer = document.querySelector('.footer-info-container');
    const footerInfo = document.getElementById('footerInfo');

    // ========== 1. Code to Key Display Mapping Function ==========
    const codeToKeyMap = {
      // Numbers
      'Digit0': '0', 'Digit1': '1', 'Digit2': '2', 'Digit3': '3', 'Digit4': '4',
      'Digit5': '5', 'Digit6': '6', 'Digit7': '7', 'Digit8': '8', 'Digit9': '9',
      // Letters
      'KeyA': 'A', 'KeyB': 'B', 'KeyC': 'C', 'KeyD': 'D', 'KeyE': 'E', 'KeyF': 'F',
      'KeyG': 'G', 'KeyH': 'H', 'KeyI': 'I', 'KeyJ': 'J', 'KeyK': 'K', 'KeyL': 'L',
      'KeyM': 'M', 'KeyN': 'N', 'KeyO': 'O', 'KeyP': 'P', 'KeyQ': 'Q', 'KeyR': 'R',
      'KeyS': 'S', 'KeyT': 'T', 'KeyU': 'U', 'KeyV': 'V', 'KeyW': 'W', 'KeyX': 'X',
      'KeyY': 'Y', 'KeyZ': 'Z',
      // Special characters
      'Minus': '-', 'Equal': '=', 'BracketLeft': '[', 'BracketRight': ']',
      'Backslash': '\\', 'Semicolon': ';', 'Quote': '\'', 'Comma': ',', 'Period': '.', 'Slash': '/',
      'Backquote': '`',
      // Numpad
      'Numpad0': 'Num0', 'Numpad1': 'Num1', 'Numpad2': 'Num2', 'Numpad3': 'Num3', 'Numpad4': 'Num4',
      'Numpad5': 'Num5', 'Numpad6': 'Num6', 'Numpad7': 'Num7', 'Numpad8': 'Num8', 'Numpad9': 'Num9',
      'NumpadAdd': '+', 'NumpadSubtract': '-', 'NumpadMultiply': '*', 'NumpadDivide': '/',
      'NumpadDecimal': '.',
      // Function keys
      'Space': 'Space', 'Tab': 'Tab', 'Enter': 'Enter', 'Backspace': 'Backspace',
      'Escape': 'Esc',
      // Arrow keys
      'ArrowUp': '↑', 'ArrowDown': '↓', 'ArrowLeft': '←', 'ArrowRight': '→',
      // Other keys
      'CapsLock': 'Caps', 'ContextMenu': 'Menu',
      'Insert': 'Ins', 'Delete': 'Del', 'Home': 'Home', 'End': 'End', 'PageUp': 'PgUp', 'PageDown': 'PgDn',
    };

    /**
     * Convert code to user-friendly display character
     * @param {string} code - Keyboard event code
     * @returns {string} User-friendly display character
     */
    function codeToDisplayKey(code) {
      // Modifier key handling
      if (code === 'cmd' || code === 'command') return '⌘';
      if (code === 'ctrl' || code === 'control') return platform === 'mac' ? '⌃' : 'Ctrl';
      if (code === 'alt' || code === 'option') return platform === 'mac' ? '⌥' : 'Alt';
      if (code === 'shift') return '⇧';
      if (code === 'win' || code === 'windows') return '⊞';
      if (code === 'fn' || code === 'function') return platform === 'mac' ? 'fn' : 'Fn';
      if (code === 'capslock' || code === 'caps') return '⇪';

      // Use mapping table
      return codeToKeyMap[code] || code.toUpperCase();
    }

    // ========== 2. Unified Shortcut Card Component ==========
    /**
     * Create shortcut card component
     * @param {Object} options - Config options
     * @param {string} options.actionId - Action ID
     * @param {string} options.actionName - Action name
     * @param {string} options.shortcut - Shortcut string
     * @param {boolean} options.isCustomAction - Is custom action
     * @param {boolean} options.hasConflict - Has conflict
     * @param {string} options.tooltipText - Tooltip text
     * @param {Function} options.onCardClick - Card click callback
     * @param {boolean} options.allowCommandClick - Allow command click
     * @param {boolean} options.allowSetShortcut - Allow set shortcut
     * @returns {string} HTML string
     */
    function createShortcutCard(options) {
      const {
        actionId,
        actionName,
        shortcut,
        isCustomAction = false,
        hasConflict = false,
        tooltipText = '',
        onCardClick = null,
        allowCommandClick = false,
        allowSetShortcut = false
      } = options;

      const cardClasses = [
        'shortcut-card',
        isCustomAction ? 'custom-action' : '',
        hasConflict ? 'conflict' : '',
        onCardClick ? 'clickable' : ''
      ].filter(Boolean).join(' ');

      const tooltipAttr = tooltipText ? ` data-tooltip="${tooltipText}"` : '';

      return `
        <div class="${cardClasses}" data-action="${actionId}"${tooltipAttr}>
          <div class="shortcut-name">${actionName}</div>
          ${createSetShortcutButton({ actionId, shortcut, allowSetShortcut })}
        </div>
      `;
    }

    /**
     * Get shortcut (from official or temporary storage)
     * @param {string} actionId - Action ID
     * @returns {string} Shortcut string
     */
    function getShortcut(actionId) {
      return tempShortcuts[actionId] || shortcuts[actionId] || '';
    }

    /**
     * Create set shortcut button component
     * @param {Object} options - Config options
     * @param {string} options.actionId - Action ID
     * @param {string} options.shortcut - Shortcut string
     * @param {boolean} options.allowSetShortcut - Allow set shortcut
     * @returns {string} HTML string
     */
    function createSetShortcutButton(options) {
      const { actionId, shortcut, allowSetShortcut } = options;

      const hasShortcut = shortcut && shortcut.length > 0;
      const state = hasShortcut ? 'state-set' : 'state-empty';
      // Always clickable, controlled via CSS pointer-events

      return `
        <div class="shortcut-button ${state} clickable ${allowSetShortcut ? '' : 'disabled'}" data-action="${actionId}">
          <div class="action-button">Set Shortcut</div>
          <div class="key-display">${hasShortcut ? renderShortcutKeys(shortcut) : ''}</div>
        </div>
      `;
    }

    /**
     * Render shortcut display
     * @param {string} shortcut - Shortcut string
     * @returns {string} HTML string
     */
    function renderShortcutKeys(shortcut) {
      if (!shortcut) return '';

      const keys = shortcut.split('+');
      return keys.map(key => `<span class="key-text">${codeToDisplayKey(key)}</span>`).join('');
    }

    // ========== 3. Unified Status Bar Component ==========
    /**
     * Update status bar
     * @param {string} state - State ('wait-action' | 'listening-set' | 'warning')
     * @param {string} title - Title
     * @param {string} description - Description
     * @param {boolean} isFloat - Is floating style
     */
    function updateStatusBar(state, title, description, isFloat = false) {
      const statusBarEl = statusBar;
      const titleEl = statusBarEl.querySelector('.status-bar-title');
      const descEl = statusBarEl.querySelector('.status-bar-description');

      // Update state class
      statusBarEl.className = `status-bar ${state}${isFloat ? ' float' : ''}`;

      // Update content
      titleEl.innerHTML = title;
      descEl.textContent = description;
    }

    // ========== 4. Set Shortcut Function ==========
    /**
     * Start setting shortcut
     * @param {string} actionId - Action ID
     * @param {boolean} commandTriggered - Whether triggered by command click
     */
    function startSetShortcut(actionId, commandTriggered = false) {
      if (isListening) return;

      isListening = true;
      listeningActionId = actionId;
      ignoreFirstKeyUp = commandTriggered;
      shortcutSaved = false; // Initialize save status
      pressedCodes.clear();
      currentlyPressed.clear();

      // Update button state
      const button = document.querySelector(`[data-action="${actionId}"] .shortcut-button`);
      if (button) {
        button.className = 'shortcut-button state-listening clickable';
        const actionBtn = button.querySelector('.action-button');
        if (actionBtn) {
          actionBtn.textContent = 'Press keys...';
          actionBtn.classList.add('listening');
        }
      }

      // Special handling for shortcut button on custom action page
      if (currentPage === 'addCustom') {
        const customShortcutButton = document.querySelector('#customShortcutBtn .shortcut-button');
        if (customShortcutButton && customShortcutButton.dataset.action === actionId) {
          customShortcutButton.className = 'shortcut-button state-listening clickable';
          const actionBtn = customShortcutButton.querySelector('.action-button');
          if (actionBtn) {
            actionBtn.textContent = 'Press keys...';
            actionBtn.classList.add('listening');
          }
        }
      }

      // Update status bar
      const actionName = getActionName(actionId);
      const isFloat = currentPage === 'config' || currentPage === 'addCustom';
      updateStatusBar('listening-set', `Press keys to set shortcut<span class="dots-animation"></span>`, 'ESC to cancel • DELETE to remove', isFloat);

      // Show floating status bar on config and custom pages
      if (currentPage === 'config' || currentPage === 'addCustom') {
        statusBarContainer.classList.remove('hidden');
        statusBar.classList.add('float');
      }

      focusable.focus();
    }

    /**
     * Stop setting shortcut
     */
    function stopSetShortcut() {
      if (!isListening) return;

      isListening = false;
      const actionId = listeningActionId;
      listeningActionId = null;
      ignoreFirstKeyUp = false;
      shortcutSaved = false; // Reset save status
      pressedCodes.clear(); // Clear accumulated keys
      currentlyPressed.clear(); // Clear currently pressed keys

      if (delayTimer) {
        clearTimeout(delayTimer);
        delayTimer = null;
      }

      // Restore button state
      updateShortcutButton(actionId);

      // Restore status bar
      if (currentPage === 'main') {
        updateStatusBar('wait-action', 'Capturing Keys<span class="dots-animation"></span>', 'Press shortcuts to run actions • ⌘+Click to configure');
      } else if (currentPage === 'config' || currentPage === 'addCustom') {
        statusBarContainer.classList.add('hidden');
        statusBar.classList.remove('float');
      }
    }

    // ========== Helper Functions ==========
    /**
     * Get action name
     */
    function getActionName(actionId) {
      // Search default actions
      for (const category in defaultActions) {
        if (defaultActions[category][actionId]) {
          return defaultActions[category][actionId];
        }
      }

      // Search custom actions
      const customAction = customActions.find(a => a.id === actionId);
      if (customAction) {
        return customAction.name;
      }

      return actionId;
    }

    /**
     * Check if is custom action
     */
    function isCustomAction(actionId) {
      return actionId.startsWith('custom_');
    }

    /**
     * Detect shortcut conflicts
     */
    function detectShortcutConflicts() {
      const conflicts = {};
      const shortcutToActions = {};

      // Build shortcut to action mapping
      for (const [action, shortcut] of Object.entries(shortcuts)) {
        if (shortcut) {
          if (!shortcutToActions[shortcut]) {
            shortcutToActions[shortcut] = [];
          }
          shortcutToActions[shortcut].push(action);
        }
      }

      // Find conflicts
      for (const [shortcut, actions] of Object.entries(shortcutToActions)) {
        if (actions.length > 1) {
          for (const action of actions) {
            conflicts[action] = actions.filter(a => a !== action);
          }
        }
      }

      return conflicts;
    }

    /**
     * Get conflict tooltip text
     */
    function getConflictTooltipText(action) {
      const conflicts = detectShortcutConflicts();
      const conflictingActions = conflicts[action];

      if (!conflictingActions || conflictingActions.length === 0) {
        return null;
      }

      const conflictNames = conflictingActions.map(conflictAction => getActionName(conflictAction));
      return `Shortcut conflict with: ${conflictNames.join(', ')}`;
    }

    /**
     * Platform detection
     */
    function detectPlatform() {
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes('mac')) {
        platform = 'mac';
      } else if (userAgent.includes('win')) {
        platform = 'windows';
      } else {
        platform = 'linux';
      }
      document.body.className = `platform-${platform}`;
    }

    // ========== Render Functions ==========
    /**
     * Render shortcuts list (main page)
     */
    function renderShortcutsList() {
      const hasShortcuts = Object.keys(shortcuts).length > 0;

      if (!hasShortcuts) {
        shortcutsList.innerHTML = `
          <div class="empty-state">
            <h2>No shortcuts configured yet</h2>
            <button class="button" id="configureBtn" style="margin-top: 16px;">Configure Shortcuts</button>
          </div>
        `;
        return;
      }

      const conflicts = detectShortcutConflicts();
      let html = '';

      html += `<div class="shortcuts-list-header">
        <p class="section-title">Shortcuts</p>
        <button class="iconBtnSmall" id="configureBtn">
          <svg width="24" height="24" fill="none" viewBox="0 0 24 24">
            <path fill="#000" d="M8.5 18a.5.5 0 0 0 .5-.5v-1.55a2.5 2.5 0 0 0 0-4.9V6.5a.5.5 0 0 0-1 0v4.55a2.501 2.501 0 0 0 0 4.9v1.55a.5.5 0 0 0 .5.5m7 0a.5.5 0 0 0 .5-.5v-4.55a2.501 2.501 0 0 0 0-4.9V6.5a.5.5 0 0 0-1 0v1.55a2.5 2.5 0 0 0 0 4.9v4.55a.5.5 0 0 0 .5.5m0-6a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m-7 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3"></path>
          </svg>
        </button>
      </div>`;

      // reverse shortcuts list, show new shortcuts on top
      const shortcutEntries = Object.entries(shortcuts).reverse();

      for (const [action, shortcut] of shortcutEntries) {
        const actionName = getActionName(action);
        const isCustom = isCustomAction(action);
        const hasConflict = conflicts[action] && conflicts[action].length > 0;
        const tooltipText = hasConflict ? getConflictTooltipText(action) : '';

        html += createShortcutCard({
          actionId: action,
          actionName: actionName,
          shortcut: shortcut,
          isCustomAction: isCustom,
          hasConflict: hasConflict,
          tooltipText: tooltipText,
          onCardClick: true, // main page allows click to run action
          allowCommandClick: true,
          allowSetShortcut: false // main page does not show set shortcut button
        });
      }

      shortcutsList.innerHTML = html;
    }

    /**
     * Render config list (config page)
     */
    function renderConfigList() {
      const conflicts = detectShortcutConflicts();

      // render default actions
      let defaultHtml = '';
      const categories = Object.keys(defaultActions);

      categories.forEach(category => {
        defaultHtml += `<h3 class="category-title">${category}</h3>`;

        const actionsInCategory = Object.entries(defaultActions[category]);

        actionsInCategory.forEach(([action, name]) => {
          const shortcut = shortcuts[action] || '';
          const hasConflict = conflicts[action] && conflicts[action].length > 0;
          const tooltipText = hasConflict ? getConflictTooltipText(action) : '';

          defaultHtml += createShortcutCard({
            actionId: action,
            actionName: name,
            shortcut: shortcut,
            isCustomAction: false,
            hasConflict: hasConflict,
            tooltipText: tooltipText,
            onCardClick: null, // config page does not allow click to run action
            allowCommandClick: true,
            allowSetShortcut: true
          });
        });
      });

      document.getElementById('defaultConfigList').innerHTML = defaultHtml;

      // render custom actions
      let customHtml = '';
      customActions.forEach(action => {
        const shortcut = shortcuts[action.id] || '';
        const hasConflict = conflicts[action.id] && conflicts[action.id].length > 0;
        const tooltipText = hasConflict ? getConflictTooltipText(action.id) : '';

        customHtml += createShortcutCard({
          actionId: action.id,
          actionName: action.name,
          shortcut: shortcut,
          isCustomAction: true,
          hasConflict: hasConflict,
          tooltipText: tooltipText,
          onCardClick: () => editCustomAction(action.id), // custom action click to edit
          allowCommandClick: true,
          allowSetShortcut: true
        });
      });

      document.getElementById('customConfigList').innerHTML = customHtml;
    }

    // ========== Page Management ==========
    /**
     * Show page
     */
    function showPage(pageName) {
      pages.forEach(page => page.classList.remove('active'));

      // Reset footerInfo when switching page
      hideFooterInfo();

      switch (pageName) {
        case 'main':
          document.getElementById('mainPage').classList.add('active');
          currentPage = 'main';
          statusBarContainer.classList.remove('hidden');
          updateStatusBar('wait-action', 'Capturing Keys<span class="dots-animation"></span>', 'Press shortcuts to run actions • ⌘+Click to configure');
          renderShortcutsList();
          // mainPage footerInfo text
          break;
        case 'config':
          document.getElementById('configPage').classList.add('active');
          currentPage = 'config';
          if (!isListening) {
            statusBarContainer.classList.add('hidden');
          }
          renderConfigList();
          // configPage footerInfo text
          break;
        case 'addCustom':
          document.getElementById('addCustomPage').classList.add('active');
          currentPage = 'addCustom';
          statusBarContainer.classList.add('hidden');
          if (!currentEditingActionId) {
            clearCustomForm();
            clearTempShortcuts();
            const customId = 'custom_' + Date.now();
            const customShortcutContainer = document.getElementById('customShortcutBtn');
            customShortcutContainer.innerHTML = createSetShortcutButton({
              actionId: customId,
              shortcut: '',
              allowSetShortcut: true
            });
          }
          updateCustomFormActions();
          // addCustomPage does not show footerInfo
          hideFooterInfo();
          break;
      }
      setTimeout(() => {
        const searchContent = document.querySelector('.search-content');
        if (
          pageName === 'main' &&
          !isListening &&
          !searchContent.classList.contains('active')
        ) {
          focusable.focus();
        }
      }, 100);
    }

    /**
     * Switch tab
     */
    function switchTab(tabName) {
      tabs.forEach(tab => tab.classList.remove('active'));
      tabContents.forEach(content => content.classList.remove('active'));

      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`${tabName}Tab`).classList.add('active');

      currentTab = tabName;
    }

    // ========== 5. Listen Key Function ==========
    /**
     * Handle keydown
     */
    function handleKeyDown(event) {
      const key = event.key.toLowerCase();
      const code = event.code;

      // Allow form input on addCustom page when not listening
      if (currentPage === 'addCustom' && !isListening) {
        return;
      }

      // On keydown
      if (isListening) {
        // ESC cancel
        if (key === 'escape') {
          event.preventDefault();
          cancelSetShortcut();
          return;
        }

        // DELETE remove shortcut
        if (key === 'delete' || key === 'backspace') {
          event.preventDefault();
          deleteShortcut();
          return;
        }

        event.preventDefault();
        console.log('KeyDown:', code, 'metaKey:', event.metaKey, 'currentlyPressed before:', Array.from(currentlyPressed));

        // Clear delay timer
        if (delayTimer) {
          clearTimeout(delayTimer);
          delayTimer = null;
        }

        // Add modifier keys to both sets
        if (event.metaKey) {
          pressedCodes.add('cmd');
          currentlyPressed.add('cmd');
        }
        if (event.ctrlKey) {
          pressedCodes.add('ctrl');
          currentlyPressed.add('ctrl');
        }
        if (event.altKey) {
          pressedCodes.add('alt');
          currentlyPressed.add('alt');
        }
        if (event.shiftKey) {
          pressedCodes.add('shift');
          currentlyPressed.add('shift');
        }

        // Add main key (non-modifier)
        const modifierCodes = ['MetaLeft', 'MetaRight', 'ControlLeft', 'ControlRight', 'AltLeft', 'AltRight', 'ShiftLeft', 'ShiftRight'];
        if (!modifierCodes.includes(code)) {
          pressedCodes.add(code); // Accumulated for display
          currentlyPressed.add(code); // Currently pressed
        }

        console.log('KeyDown currentlyPressed after:', Array.from(currentlyPressed));

        // Real-time update of status bar display (show all pressed keys)
        updateListeningStatusBar();

        // Check if there is a non-modifier key
        const allCodes = Array.from(pressedCodes);
        const nonModifierCodes = allCodes.filter(c => !['cmd', 'ctrl', 'alt', 'shift'].includes(c));
        const modifierCodes_check = allCodes.filter(c => ['cmd', 'ctrl', 'alt', 'shift'].includes(c));

        if (nonModifierCodes.length > 0) {
          if (nonModifierCodes.length === 1) {
            // If has one main key, save immediately (regardless of modifiers)
            captureShortcut();
          } else {
            // Multiple main keys, invalid combination
            // Do nothing, wait for user action
          }
        }
      }
      // ESC handler for other pages
      else if (key === 'escape') {
        event.preventDefault();
        if (currentPage === 'main') {
          parent.postMessage({ pluginMessage: { type: 'close-plugin' } }, '*');
        } else if (currentPage === 'config') {
          showPage('main');
        } else if (currentPage === 'addCustom') {
          showPage('config');
        }
      }
      // Execute shortcut on main page
      else if (currentPage === 'main') {
        const shortcut = getShortcutFromEvent(event);
        executeShortcut(shortcut);
      }
    }

    /**
     * Handle keyup
     */
    function handleKeyUp(event) {
      const code = event.code;

      if (currentPage === 'addCustom' && !isListening) {
        return;
      }

      // On keyup
      if (isListening) {
        // Ignore first keyup (when triggered by command click)
        if (ignoreFirstKeyUp) {
          ignoreFirstKeyUp = false;
          console.log('Ignored first keyup:', code);
          return;
        }

        event.preventDefault();
        console.log('KeyUp:', code, 'metaKey:', event.metaKey, 'currentlyPressed before:', Array.from(currentlyPressed));

        // Remove key from currently pressed set
        currentlyPressed.delete(code);
        if (!event.metaKey) currentlyPressed.delete('cmd');
        if (!event.ctrlKey) currentlyPressed.delete('ctrl');
        if (!event.altKey) currentlyPressed.delete('alt');
        if (!event.shiftKey) currentlyPressed.delete('shift');

        console.log('currentlyPressed after:', Array.from(currentlyPressed));

        // Check if need to clear state or exit listening
        if (currentlyPressed.size === 0) {
          console.log('All keys released, checking exit condition. pressedCodes:', Array.from(pressedCodes), 'shortcutSaved:', shortcutSaved);
          if (currentlyPressed.size === 0 && isListening) {
            // Check if only modifier keys were pressed
            const allPressedCodes = Array.from(pressedCodes);
            const modifierKeys = ['cmd', 'ctrl', 'alt', 'shift'];
            const hasOnlyModifiers = allPressedCodes.length > 0 && allPressedCodes.every(k => modifierKeys.includes(k));

            console.log('hasOnlyModifiers:', hasOnlyModifiers, 'shortcutSaved:', shortcutSaved);

            if (hasOnlyModifiers && !shortcutSaved) {
              // Only modifier keys were pressed and shortcut not saved, clear and keep listening
              console.log('Continue listening - only modifiers');
              pressedCodes.clear();
              updateListeningStatusBar();
            } else {
              // Has main key, shortcut saved, or no keys pressed, exit listening
              console.log('Exit listening - has main key or saved shortcut');
              stopSetShortcut();
            }
          }
        } else if (shortcutSaved) {
          // Special case: shortcut saved but some keys still pressed (maybe missed keyup)
          // Check actual modifier key state
          const actualModifiers = [];
          if (event.metaKey) actualModifiers.push('cmd');
          if (event.ctrlKey) actualModifiers.push('ctrl');
          if (event.altKey) actualModifiers.push('alt');
          if (event.shiftKey) actualModifiers.push('shift');

          console.log('Checking for lost keyup events. actualModifiers:', actualModifiers, 'currentlyPressed:', Array.from(currentlyPressed));

          // If actually no modifiers pressed but currentlyPressed is not empty
          if (actualModifiers.length === 0 && currentlyPressed.size > 0) {
            console.log('Detected lost keyup events, force clearing currentlyPressed');
            currentlyPressed.clear();
            // Re-check exit condition
            if (currentlyPressed.size === 0 && isListening) {
              console.log('Force exit after clearing lost keys');
              stopSetShortcut();
            }
          }
        }
      }
    }

    /**
     * Update status bar display in listening state
     */
    function updateListeningStatusBar() {
      if (!isListening) return;

      const keys = Array.from(pressedCodes);
      let keysDisplay = '';

      if (keys.length > 0) {
        // Sort keys: modifiers first, then main key
        const modifierOrder = ['cmd', 'ctrl', 'alt', 'shift'];
        const modifiers = keys.filter(k => modifierOrder.includes(k)).sort((a, b) => modifierOrder.indexOf(a) - modifierOrder.indexOf(b));
        const mainKeys = keys.filter(k => !modifierOrder.includes(k));

        const sortedKeys = [...modifiers, ...mainKeys];
        keysDisplay = sortedKeys.map(key => codeToDisplayKey(key)).join(' + ');
      }

      const actionName = getActionName(listeningActionId);
      const isFloat = currentPage === 'config' || currentPage === 'addCustom';

      if (keysDisplay) {
        updateStatusBar('listening-set', keysDisplay, 'Press more keys or release to set shortcut', isFloat);
      } else {
        updateStatusBar('listening-set', `Press keys to set shortcut<span class="dots-animation"></span>`, 'ESC to cancel • DELETE to remove', isFloat);
      }

      // add float style on config and custom pages
      if (isFloat) {
        statusBar.classList.add('float');
      }
    }

    /**
     * Capture shortcut
     */
    function captureShortcut() {
      if (!isListening || !listeningActionId || pressedCodes.size === 0) return;

      const keys = Array.from(pressedCodes);
      const modifierKeys = ['cmd', 'ctrl', 'alt', 'shift'];
      const modifiers = keys.filter(k => modifierKeys.includes(k));
      const mainKeys = keys.filter(k => !modifierKeys.includes(k));

      // Validate shortcut rules
      if (mainKeys.length === 0) {
        // Only modifier keys, invalid
        const actionName = getActionName(listeningActionId);
        const isFloat = currentPage === 'config' || currentPage === 'addCustom';
        updateStatusBar('listening-set', `Invalid shortcut`, 'Need at least one main key • ESC to cancel • DELETE to remove', isFloat);

        // Ensure float style on config and custom pages
        if (isFloat) {
          statusBar.classList.add('float');
        }

        return;
      }

      if (mainKeys.length > 1) {
        // Multiple main keys, invalid
        const actionName = getActionName(listeningActionId);
        const isFloat = currentPage === 'config' || currentPage === 'addCustom';
        updateStatusBar('listening-set', `Invalid shortcut`, 'Only one main key allowed • ESC to cancel • DELETE to remove', isFloat);

        // Ensure float style on config and custom pages
        if (isFloat) {
          statusBar.classList.add('float');
        }

        return;
      }

      // Build shortcut string: modifiers first, then main key
      const modifierOrder = ['cmd', 'ctrl', 'alt', 'shift'];
      const sortedModifiers = modifiers.sort((a, b) => modifierOrder.indexOf(a) - modifierOrder.indexOf(b));
      const shortcutKeys = [...sortedModifiers, ...mainKeys];
      const shortcut = shortcutKeys.join('+');

      // Save shortcut
      if (currentPage === 'addCustom') {
        // On custom action page, save temporarily
        tempShortcuts[listeningActionId] = shortcut;
      } else {
        // On other pages, save immediately
        shortcuts[listeningActionId] = shortcut;
        saveData();

        // Only send success notification on non-custom action page
        const actionName = getActionName(listeningActionId);
        parent.postMessage({
          pluginMessage: {
            type: 'shortcut-set-success',
            actionName: actionName
          }
        }, '*');
      }

      // Update UI - only update corresponding shortcut button, do not re-render entire list
      updateShortcutButton(listeningActionId);

      // Mark as saved, but do not stop listening immediately
      shortcutSaved = true;
    }

    /**
     * Cancel setting shortcut
     */
    function cancelSetShortcut() {
      if (!isListening) return;

      // Clear all keys and reset state
      shortcutSaved = false;
      pressedCodes.clear();
      currentlyPressed.clear();

      stopSetShortcut();
    }

    /**
     * Delete shortcut
     */
    function deleteShortcut() {
      if (!isListening || !listeningActionId) return;

      const actionId = listeningActionId;
      const actionName = getActionName(actionId);

      if (currentPage === 'addCustom') {
        // On custom action page, delete temporary shortcut
        delete tempShortcuts[actionId];
      } else {
        // On other pages, delete official shortcut
        delete shortcuts[actionId];
        saveData();
      }

      // Clear all keys and reset state
      shortcutSaved = false;
      pressedCodes.clear();
      currentlyPressed.clear();

      // Update UI
      if (currentPage === 'main') {
        // On main page, re-render entire list as deleting shortcut may affect list structure
        setTimeout(() => {
          renderShortcutsList();
        }, 20);
      } else {
        // On other pages, only update corresponding shortcut button
        updateShortcutButton(actionId);
      }

      const isFloat = currentPage === 'config' || currentPage === 'addCustom';
      updateStatusBar('listening-set', `Shortcut removed`, 'Shortcut removed successfully', isFloat);

      // Ensure float style on config and custom pages
      if (isFloat) {
        statusBar.classList.add('float');
      }

      setTimeout(() => {
        stopSetShortcut();
      }, 1000);
    }

    /**
     * Get shortcut from event
     */
    function getShortcutFromEvent(event) {
      const keys = [];

      if (event.metaKey) keys.push('cmd');
      if (event.ctrlKey) keys.push('ctrl');
      if (event.altKey) keys.push('alt');
      if (event.shiftKey) keys.push('shift');

      const code = event.code;
      const modifierCodes = ['MetaLeft', 'MetaRight', 'ControlLeft', 'ControlRight', 'AltLeft', 'AltRight', 'ShiftLeft', 'ShiftRight'];
      if (!modifierCodes.includes(code)) {
        keys.push(code);
      }

      return keys.length > 0 ? keys.join('+') : null;
    }

    /**
     * Execute shortcut
     */
    function executeShortcut(shortcut, closePlugin = true) {
      for (const [action, actionShortcut] of Object.entries(shortcuts)) {
        if (actionShortcut === shortcut) {
          updateStatusBar('wait-action', `Executing: ${getActionName(action)}`, '');

          parent.postMessage({
            pluginMessage: {
              type: 'shortcut-triggered',
              action: action,
              closePlugin: closePlugin
            }
          }, '*');

          setTimeout(() => {
            updateStatusBar('wait-action', 'Capturing Keys<span class="dots-animation"></span>', 'Press shortcuts to run actions • ⌘+Click to configure');
          }, 1000);

          return;
        }
      }
    }

    // ========== Data Management ==========
    function loadData() {
      parent.postMessage({
        pluginMessage: {
          type: 'load-data'
        }
      }, '*');
    }

    function saveData() {
      parent.postMessage({
        pluginMessage: {
          type: 'save-data',
          shortcuts: shortcuts,
          customActions: customActions
        }
      }, '*');
    }

    // ========== Custom Action Management ==========
    function clearCustomForm() {
      document.getElementById('customActionName').value = '';
      document.getElementById('customActionFunction').value = '';

      const headerTitle = document.querySelector('#addCustomPage h2');
      if (headerTitle) {
        headerTitle.textContent = 'Add Custom Action';
      }

      currentEditingActionId = null;
    }

    function clearTempShortcuts() {
      tempShortcuts = {};
    }

    /**
     * Update shortcut button display for specified action
     * @param {string} actionId - Action ID
     */
    /**
     * Update single shortcut button
     */
    function updateSingleShortcutButton(button, actionId) {
      // If currently listening to this button, do not override listening state
      if (isListening && listeningActionId === actionId) {
        return;
      }

      const currentShortcut = getShortcut(actionId);
      const hasShortcut = currentShortcut && currentShortcut.length > 0;
      const isMainPage = currentPage === 'main';

      // Update button state class
      button.className = `shortcut-button ${hasShortcut ? 'state-set' : 'state-empty'} clickable ${isMainPage ? 'disabled' : ''}`;

      // Update button text
      const actionBtn = button.querySelector('.action-button');
      if (actionBtn) {
        actionBtn.textContent = 'Set Shortcut';
        actionBtn.classList.remove('listening');
      }

      // Update key display
      const keyDisplay = button.querySelector('.key-display');
      if (keyDisplay) {
        if (hasShortcut) {
          keyDisplay.innerHTML = renderShortcutKeys(currentShortcut);
        } else {
          keyDisplay.innerHTML = '';
        }
      }
    }

    function updateShortcutButton(actionId) {
      // Find all shortcut buttons for this action on all pages
      const buttons = document.querySelectorAll(`[data-action="${actionId}"] .shortcut-button`);
      buttons.forEach(button => updateSingleShortcutButton(button, actionId));

      // Special handling for shortcut button on custom action page
      if (currentPage === 'addCustom') {
        const customShortcutButton = document.querySelector('#customShortcutBtn .shortcut-button');
        if (customShortcutButton && customShortcutButton.dataset.action === actionId) {
          updateSingleShortcutButton(customShortcutButton, actionId);
        }
      }
    }

    function saveCustomAction(update = false) {
      const name = document.getElementById('customActionName').value.trim();
      const functionCode = document.getElementById('customActionFunction').value.trim();

      if (!name || !functionCode) {
        alert('Please fill in all fields');
        return;
      }

      if (functionCode.includes('postMessage')) {
        alert('Security violation: postMessage is not allowed in custom actions');
        return;
      }

      let action;
      let actionId;

      if (currentEditingActionId) {
        actionId = currentEditingActionId;
        const existingActionIndex = customActions.findIndex(a => a.id === currentEditingActionId);
        if (existingActionIndex !== -1) {
          customActions[existingActionIndex] = {
            ...customActions[existingActionIndex],
            name: name,
            function: functionCode
          };
          action = customActions[existingActionIndex];
        }
      } else {
        const customShortcutButton = document.querySelector('#customShortcutBtn .shortcut-button');
        actionId = customShortcutButton ? customShortcutButton.dataset.action : 'custom_' + Date.now();
        action = { id: actionId, name, function: functionCode };
        customActions.push(action);
      }

      // Save temporary shortcut to official storage
      if (tempShortcuts[actionId]) {
        shortcuts[actionId] = tempShortcuts[actionId];
        delete tempShortcuts[actionId];
      }

      saveData();

      parent.postMessage({
        pluginMessage: {
          type: 'custom-action-added',
          action: action,
          update: update
        }
      }, '*');

      renderShortcutsList();
      currentEditingActionId = null;
      clearTempShortcuts(); // Clear all temporary shortcuts
      showPage('config');
    }

    function editCustomAction(actionId) {
      const action = customActions.find(a => a.id === actionId);
      if (!action) return;

      currentEditingActionId = actionId;
      showPage('addCustom');

      setTimeout(() => {
        document.getElementById('customActionName').value = action.name;
        document.getElementById('customActionFunction').value = action.function;

        const customShortcutContainer = document.getElementById('customShortcutBtn');
        const shortcut = getShortcut(actionId);
        customShortcutContainer.innerHTML = createSetShortcutButton({
          actionId: actionId,
          shortcut: shortcut,
          allowSetShortcut: true
        });

        const headerTitle = document.querySelector('#addCustomPage h2');
        if (headerTitle) {
          headerTitle.textContent = 'Edit Custom Action';
        }

        updateCustomFormActions();
      }, 10);
    }

    function deleteCustomAction() {
      if (!currentEditingActionId) return;

      if (confirm('Are you sure you want to delete this custom action?')) {
        const actionIndex = customActions.findIndex(a => a.id === currentEditingActionId);
        if (actionIndex !== -1) {
          customActions.splice(actionIndex, 1);
        }

        if (shortcuts[currentEditingActionId]) {
          delete shortcuts[currentEditingActionId];
        }

        // Clear temporary shortcut
        if (tempShortcuts[currentEditingActionId]) {
          delete tempShortcuts[currentEditingActionId];
        }

        saveData();
        renderShortcutsList();
        renderConfigList();
        currentEditingActionId = null;
        clearTempShortcuts(); // Clear all temporary shortcuts
        showPage('config');
      }
    }

    function updateCustomFormActions() {
      const saveBtn = document.getElementById('saveCustomBtn');
      const moreGroup = document.querySelector('.more-action-button-group');
      if (currentEditingActionId) {
        saveBtn.style.display = 'none';
        moreGroup.style.display = 'flex';
      } else {
        saveBtn.style.display = 'inline-block';
        moreGroup.style.display = 'none';
      }
    }

    function testRunCustomAction() {
      const functionCode = document.getElementById('customActionFunction').value.trim();

      if (!functionCode) {
        alert('Please enter function code first');
        return;
      }

      if (functionCode.includes('postMessage')) {
        alert('Security violation: postMessage is not allowed in custom actions');
        return;
      }

      // Send test run request to plugin
      parent.postMessage({
        pluginMessage: {
          type: 'test-run-custom-action',
          functionCode: functionCode
        }
      }, '*');
    }

    // ========== 6. Config Page Related ==========
    function toggleSearch() {
      const tabsContent = document.querySelector('.tabs-content');
      const searchContent = document.querySelector('.search-content');
      const searchInput = document.getElementById('searchInput');

      if (searchContent.classList.contains('active')) {
        searchContent.classList.remove('active');
        tabsContent.style.display = 'flex';
        searchInput.value = '';
        renderConfigList();
      } else {
        searchContent.classList.add('active');
        tabsContent.style.display = 'none';
        searchInput.focus();
      }
    }

    function handleSearchInput(event) {
      const searchTerm = event.target.value.toLowerCase().trim();

      if (searchTerm === '') {
        renderConfigList();
        return;
      }

      const conflicts = detectShortcutConflicts();

      let defaultHtml = '';
      let foundResults = false;

      for (const [category, actions] of Object.entries(defaultActions)) {
        let categoryHtml = '';
        let categoryHasResults = false;

        for (const [action, name] of Object.entries(actions)) {
          if (name.toLowerCase().includes(searchTerm)) {
            const shortcut = shortcuts[action] || '';
            const hasConflict = conflicts[action] && conflicts[action].length > 0;
            const tooltipText = hasConflict ? getConflictTooltipText(action) : '';

            categoryHtml += createShortcutCard({
              actionId: action,
              actionName: name,
              shortcut: shortcut,
              isCustomAction: false,
              hasConflict: hasConflict,
              tooltipText: tooltipText,
              onCardClick: null,
              allowCommandClick: true,
              allowSetShortcut: true
            });

            categoryHasResults = true;
            foundResults = true;
          }
        }

        if (categoryHasResults) {
          defaultHtml += `<h3 class="category-title">${category}</h3>`;
          defaultHtml += categoryHtml;
        }
      }

      if (!foundResults) {
        defaultHtml = '<div class="empty-search-state">No results</div>';
      }

      let customHtml = '';
      customActions.forEach(action => {
        if (action.name.toLowerCase().includes(searchTerm)) {
          const shortcut = shortcuts[action.id] || '';
          const hasConflict = conflicts[action.id] && conflicts[action.id].length > 0;
          const tooltipText = hasConflict ? getConflictTooltipText(action.id) : '';

          customHtml += createShortcutCard({
            actionId: action.id,
            actionName: action.name,
            shortcut: shortcut,
            isCustomAction: true,
            hasConflict: hasConflict,
            tooltipText: tooltipText,
            onCardClick: () => editCustomAction(action.id),
            allowCommandClick: true,
            allowSetShortcut: true
          });
        }
      });

      document.getElementById('defaultConfigList').innerHTML = defaultHtml;
      document.getElementById('customConfigList').innerHTML = customHtml;
    }

    // ========== 7. ActionItem Render Function ==========

    // ========== 8. Custom Page Related ==========
    function setupEventListeners() {
      // Page navigation
      backBtn.addEventListener('click', () => showPage('main'));
      backToConfigBtn.addEventListener('click', () => {
        clearTempShortcuts(); // Clear temporary shortcuts
        clearCustomForm();    // Clear form and editing state
        showPage('config');
      });
      addCustomBtn.addEventListener('click', () => showPage('addCustom'));

      // Tab switching
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabName = tab.dataset.tab;
          switchTab(tabName);
        });
      });

      document.addEventListener('click', (e) => {
        // Set shortcut button click
        if (e.target.closest('.shortcut-button')) {
          const button = e.target.closest('.shortcut-button');
          const actionId = button.dataset.action;
          startSetShortcut(actionId, false);
        }
        // Configure button click
        else if (e.target.id === 'configureBtn') {
          showPage('config');
        }
        // Alt+Click on any shortcut-card to run action (no statusbar change)
        else if (e.altKey && !e.metaKey && !e.ctrlKey && e.target.closest('.shortcut-card')) {
          // Alt+Click runs action on both mainPage and configPage
          const card = e.target.closest('.shortcut-card');
          const actionId = card.dataset.action;
          e.preventDefault();
          console.log("run action")
          parent.postMessage({
            pluginMessage: {
              type: 'shortcut-triggered',
              action: actionId,
              closePlugin: false
            }
          }, '*');
          return;
        }
        // Shortcut card click (main page)
        else if (e.target.closest('.shortcut-card.clickable') && currentPage === 'main') {
          const card = e.target.closest('.shortcut-card');
          const actionId = card.dataset.action;
          if (e.altKey && !e.metaKey && !e.ctrlKey) {
            e.preventDefault();
            parent.postMessage({
              pluginMessage: {
                type: 'shortcut-triggered',
                action: actionId,
                closePlugin: false
              }
            }, '*');
            return;
          }
          if (e.metaKey || e.ctrlKey) {
            e.preventDefault();
            startSetShortcut(actionId, true);
          } else {
            const actionName = getActionName(actionId);
            updateStatusBar('wait-action', `Executing: ${actionName}`, '');
            parent.postMessage({
              pluginMessage: {
                type: 'shortcut-triggered',
                action: actionId
              }
            }, '*');
            setTimeout(() => {
              updateStatusBar('wait-action', 'Capturing Keys<span class="dots-animation"></span>', 'Press shortcuts to run actions • ⌘+Click to configure');
            }, 1000);
          }
        }
        // Command click (config page)
        else if (e.target.closest('.shortcut-card') && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          const card = e.target.closest('.shortcut-card');
          const actionId = card.dataset.action;
          startSetShortcut(actionId, true);
        }
        // Custom action card click (edit)
        else if (e.target.closest('.shortcut-card.custom-action') &&
          !e.target.closest('.shortcut-button') &&
          currentPage === 'config') {
          const card = e.target.closest('.shortcut-card');
          const actionId = card.dataset.action;
          editCustomAction(actionId);
        }
      });

      // Search functionality
      document.getElementById('searchBtn').addEventListener('click', toggleSearch);
      document.getElementById('closeSearchBtn').addEventListener('click', toggleSearch);
      document.getElementById('searchInput').addEventListener('input', handleSearchInput);

      // Form input focus
      document.getElementById('searchInput').addEventListener('click', (e) => {
        e.stopPropagation();
        e.target.focus();
      });

      document.addEventListener('click', (e) => {
        if (e.target.closest('.search-input-container')) {
          e.preventDefault();
          e.stopPropagation();
          document.getElementById('searchInput').focus();
        }
      });

      // Custom action form
      document.getElementById('saveCustomBtn').addEventListener('click', () => saveCustomAction(false));
      document.getElementById('saveCustomBtnGroup').addEventListener('click', () => saveCustomAction(true));
      document.getElementById('cancelCustomBtn').addEventListener('click', () => {
        clearTempShortcuts(); // Clear temporary shortcuts
        clearCustomForm();    // Clear form and editing state
        showPage('config');
      });
      document.getElementById('testRunBtn').addEventListener('click', testRunCustomAction);

      document.getElementById('customActionName').addEventListener('click', (e) => {
        e.stopPropagation();
        e.target.focus();
      });

      document.getElementById('customActionFunction').addEventListener('click', (e) => {
        e.stopPropagation();
        e.target.focus();
      });

      // Keyboard events
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);

      // Focus management
      document.addEventListener('click', (e) => {
        const searchContent = document.querySelector('.search-content');
        if (
          currentPage === 'main' &&
          !isListening &&
          !searchContent.classList.contains('active')
        ) {
          focusable.focus();
        }
      });

      window.addEventListener('blur', () => {
        setTimeout(() => {
          const searchContent = document.querySelector('.search-content');
          if (
            currentPage === 'main' &&
            !isListening &&
            !searchContent.classList.contains('active')
          ) {
            focusable.focus();
          }
        }, 10);
      });

      // Tooltip functionality
      let tooltip = null;
      let tooltipTimeout = null;

      function createTooltip() {
        if (tooltip) return tooltip;

        tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
      }

      function showTooltip(element, text) {
        if (!text) return;

        const tooltipEl = createTooltip();
        tooltipEl.textContent = text;
        tooltipEl.classList.add('show');

        const rect = element.getBoundingClientRect();
        const tooltipRect = tooltipEl.getBoundingClientRect();

        let left = rect.left + rect.width / 2;
        if (left + tooltipRect.width / 2 > window.innerWidth) {
          left = window.innerWidth - tooltipRect.width / 2 - 10;
        } else if (left - tooltipRect.width / 2 < 0) {
          left = tooltipRect.width / 2 + 10;
        }

        tooltipEl.style.left = left + 'px';
        tooltipEl.style.top = (rect.top - tooltipRect.height - 8) + 'px';
      }

      function hideTooltip() {
        if (tooltip) {
          tooltip.classList.remove('show');
        }
        if (tooltipTimeout) {
          clearTimeout(tooltipTimeout);
          tooltipTimeout = null;
        }
      }

      document.addEventListener('mouseover', (e) => {
        const shortcutCard = e.target.closest('.shortcut-card.conflict');
        if (shortcutCard && shortcutCard.dataset.tooltip) {
          tooltipTimeout = setTimeout(() => {
            showTooltip(shortcutCard, shortcutCard.dataset.tooltip);
          }, 100);
        }
      });

      document.addEventListener('mouseout', (e) => {
        const shortcutCard = e.target.closest('.shortcut-card.conflict');
        if (shortcutCard) {
          hideTooltip();
        }
      });

      document.addEventListener('click', hideTooltip);
      document.addEventListener('keydown', hideTooltip);

      // More actions dropdown menu
      const moreActionsBtn = document.getElementById('moreActionsBtn');
      const moreActionsDropdown = document.getElementById('moreActionsDropdown');
      let dropdownOpen = false;

      if (moreActionsBtn) {
        moreActionsBtn.addEventListener('click', function (e) {
          e.stopPropagation();
          dropdownOpen = !dropdownOpen;
          moreActionsDropdown.style.display = dropdownOpen ? 'block' : 'none';
          moreActionsBtn.classList.add('active');
        });

        document.addEventListener('click', function () {
          if (dropdownOpen) {
            moreActionsDropdown.style.display = 'none';
            dropdownOpen = false;
            moreActionsBtn.classList.remove('active');
          }
        });

        moreActionsDropdown.addEventListener('click', function (e) {
          e.stopPropagation();
        });
      }

      document.getElementById('duplicateCustomBtn').addEventListener('click', function () {
        if (!currentEditingActionId) return;
        const action = customActions.find(a => a.id === currentEditingActionId);
        if (!action) return;

        const newId = 'custom_' + Date.now();
        const newAction = { ...action, id: newId, name: action.name + ' Copy' };
        customActions.push(newAction);
        saveData();
        renderConfigList();
        showPage('config');
      });

      document.getElementById('deleteCustomBtn').addEventListener('click', function () {
        deleteCustomAction();
      });
    }

    // ========== 9. Footer Page Related ==========

    // ========== 10. Help Info Popup ==========

    // ========== Initialization ==========
    function init() {
      detectPlatform();
      loadData();
      setupEventListeners();
      focusable.focus();
      // Initialize footerInfo text
      setFooterInfoText('⌘+Click to set shortcut • ⌥+Click to run action');
    }

    // ========== Message Handling ==========
    window.addEventListener('message', (event) => {
      if (event.data.pluginMessage) {
        const msg = event.data.pluginMessage;
        if (msg.type === 'shortcut-result') {
          if (currentPage === 'main') {
            if (msg.success) {
              updateStatusBar('notify', msg.message, '');
            } else {
              updateStatusBar('warning', msg.message, '');
            }
            setTimeout(() => {
              updateStatusBar('wait-action', 'Capturing Keys<span class="dots-animation"></span>', 'Press shortcuts to run actions • ⌘+Click to configure');
            }, 2000);
          }
        } else if (msg.type === 'data-loaded') {
          shortcuts = msg.shortcuts || {};
          customActions = msg.customActions || [];
          defaultActions = msg.defaultActions || {};
          renderShortcutsList();
          renderConfigList();
        } else if (msg.type === 'test-run-result') {
        }
      }
    });

    // ========== footerInfo show/hide and text ==========
    function showFooterInfo() {
      if (isListening) return; // Do not show when listening for shortcut
      if (footerInfoContainer) footerInfoContainer.classList.remove('hidden');
    }
    function hideFooterInfo() {
      if (footerInfoContainer) footerInfoContainer.classList.add('hidden');
    }
    function setFooterInfoText(text) {
      if (footerInfo) footerInfo.innerHTML = `<p>${text}</p>`;
    }
    // ========== command/alt key listening ==========
    document.addEventListener('keydown', function (e) {
      // Only effective on main/config page
      if (currentPage !== 'main' && currentPage !== 'config') return;
      if (isListening) { hideFooterInfo(); return; }
      let needShow = false;
      if (e.metaKey && !isCmdDown) {
        isCmdDown = true;
        needShow = true;
      }
      if ((currentPage === 'config' || currentPage === 'main') && e.altKey && !isAltDown) {
        isAltDown = true;
        needShow = true;
      }
      if (needShow) showFooterInfo();
    });
    document.addEventListener('keyup', function (e) {
      // Only effective on main/config page
      if (currentPage !== 'main' && currentPage !== 'config') return;
      if (isListening) { hideFooterInfo(); return; }
      // Check if command/alt is released
      if (!e.metaKey && isCmdDown) {
        isCmdDown = false;
        // On config, don't hide if alt is still pressed
        if (!((currentPage === 'config' || currentPage === 'main') && isAltDown)) hideFooterInfo();
      }
      if ((currentPage === 'config' || currentPage === 'main') && !e.altKey && isAltDown) {
        isAltDown = false;
        // Don't hide if cmd is still pressed
        if (!isCmdDown) hideFooterInfo();
      }
    });

    // ========== Resize plugin window ==========
    const corner = document.getElementById("corner");
    function resizeWindow(e) {
      const size = {
        w: Math.max(50, Math.floor(e.clientX + 5)),
        h: Math.max(50, Math.floor(e.clientY + 5)),
      };
      parent.postMessage(
        { pluginMessage: { type: "resize", size: size } },
        "*"
      );
    }
    corner.onpointerdown = (e) => {
      corner.onpointermove = resizeWindow;
      corner.setPointerCapture(e.pointerId);
    };
    corner.onpointerup = (e) => {
      corner.onpointermove = null;
      corner.releasePointerCapture(e.pointerId);
    };
    corner.addEventListener("dblclick", (e) => {
      parent.postMessage(
        {
          pluginMessage: {
            type: "resize",
            size: { w: 320, h: 10000 },
          },
        },
        "*"
      );
    });

    // Start the app
    init();
  </script>
</body>

</html>